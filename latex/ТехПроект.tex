\section{Технический проект}
\subsection{Общая характеристика организации решения задачи}

Необходимо спроектировать и разработать приложение, который должен способствовать популяризации ролевых игр.

Приложение представляет собой набор взаимосвязанных различных окон, которые сгруппированы по разделам, содержащие текстовую, графическую информацию. Приложение располагается на компьютере.

\subsection{Обоснование выбора технологии проектирования}

На сегодняшний день информационный рынок, поставляющий программные решения в выбранной сфере, предлагает множество продуктов, позволяющих достигнуть поставленной цели – разработки приложения.

\subsubsection{Описание используемых технологий и языков программирования}

В процессе разработки приложения используются программные средства и языки программирования. Каждое программное средство и каждый язык программирования применяется для круга задач, при решении которых они необходимы.

\subsubsection{Язык программирования Python}

Python –  высокоуровневый язык программирования общего назначения с динамической строгой типизацией и автоматическим управлением памятью, ориентированный на повышение производительности разработчика, читаемости кода и его качества, а также на обеспечение переносимости написанных на нём программ. Язык является полностью объектно-ориентированным в том плане, что всё является объектами. Необычной особенностью языка является выделение блоков кода отступами. Синтаксис ядра языка минималистичен, за счёт чего на практике редко возникает необходимость обращаться к документации. Сам же язык известен как интерпретируемый и используется в том числе для написания скриптов. Недостатками языка являются зачастую более низкая скорость работы и более высокое потребление памяти написанных на нём программ по сравнению с аналогичным кодом, написанным на компилируемых языках, таких как C или C++.

\subsubsection{Язык программирования Python}

\paragraph{Достоинства языка Python}
\begin{itemize}
	\item Простота и читаемость кода: Python использует простой и чистый синтаксис, что делает код легким для понимания и обслуживания.
	\item Многофункциональность: Python подходит для создания различных типов приложений, включая веб-приложения, настольные приложения, научные вычисления, обработку данных и многое другое
	\item Большой выбор библиотек: Python имеет огромное сообщество разработчиков, что приводит к большому количеству библиотек и модулей для различных задач. Например, для машинного обучения есть библиотека TensorFlow, для веб-разработки - Django, для анализа данных - Pandas и многое другое.
	\item Кроссплатформенность: Python работает на различных операционных системах, таких как Windows, macOS, Linux и другие.
	\item Быстрая разработка: Python позволяет быстро создавать прототипы и тестировать идеи благодаря своей простоте и мощности.
\end{itemize}

\paragraph{Недостатки языка Python}

\begin{itemize}
	\item Низкая производительность: Python может быть медленнее других языков программирования, таких как C++ или Java, особенно при выполнении вычислительно сложных операций.
	\item Глобальная блокировка интерпретатора: из-за глобальной блокировки GIL (Global Interpreter Lock) в Python, многопоточные приложения могут испытывать проблемы с параллельным выполнением кода.
	\item Не самый подходящий для мобильной разработки: Python не является первым выбором для мобильной разработки из-за ограниченной поддержки на мобильных платформах.
	\item Не все библиотеки могут быть на Python: Так как Python находится в постоянном развитии, не все библиотеки могут быть доступны на этом языке.
	\item Меньшая поддержка для некоторых областей разработки, таких как игровая разработка или высокопроизводительные вычисления.
\end{itemize}

\subsubsection{Использование библиотеки Tkinter и реализация таймеров на Python}
	
\paragraph{Введение}
Библиотека Tkinter - это стандартная библиотека Python для создания графического пользовательского интерфейса (GUI). Она обладает широкими возможностями для создания разнообразных приложений с использованием различных виджетов, таких как кнопки, поля ввода, метки и многое другое.
	
\paragraph{Возможности Tkinter}
Вот некоторые из основных возможностей, предоставляемых библиотекой Tkinter:
	
\begin{itemize}
	\item Создание различных виджетов: кнопки, метки, поля ввода, списки и многое другое.
	\item Управление компоновкой виджетов с использованием менеджеров компоновки (например, grid, pack, place).
	\item Обработка событий, таких как щелчок мыши, нажатие клавиш и другие.
	\item Возможность создания различных диалоговых окон, таких как окна предупреждений, информационные окна и окна запроса.
	\item Поддержка многопоточности для обновления интерфейса из различных потоков выполнения.
\end{itemize}
	
\paragraph{Реализация таймеров на Python}
Для реализации таймеров на Python можно использовать модуль \texttt{time} или \texttt{threading}. Вот пример использования модуля \texttt{time} для создания простого таймера:
	
	import time
	
	def countdown(t):
	while t > 0:
	mins, secs = divmod(t, 60)
	timeformat = '{:02d}:{:02d}'.format(mins, secs)
	print(timeformat, end='\r')
	time.sleep(1)
	t -= 1
	print('Таймер завершен!')
	
	\# Установка времени для таймера (в секундах)
	t = 10
	countdown(t)
	
Этот код создает простой обратный отсчет таймера с использованием функции \texttt{countdown}. Он выводит оставшееся время в формате ММ:СС и уменьшает его на 1 каждую секунду, используя функцию \texttt{time.sleep(1)}. Когда время истекает, выводится сообщение о завершении таймера.
	
\paragraph{Заключение}
Библиотека Tkinter предоставляет мощные инструменты для создания графических пользовательских интерфейсов на языке Python. Реализация таймеров на Python может быть достигнута с помощью модулей \texttt{time} или \texttt{threading}, в зависимости от конкретных требований приложения.

\subsection{Описание платформы для создания RPG игр}
Клиент создает модуль содержащий методы модуля RPGGame, например bggame. В этом модуле мы создаем мир игры, с помощью new\_actor. Мы можем вызывать их много раз с разными параметрами, или загрузить параметры для этих функций из файла. После чего у нас есть персонажи и предметы. Мир также состоит из зон (Area). Каждая зона включает в себя графику, персонажи и предметы и сценарии взаимодействия. Исключение составляет команда PC, которая может перемещаться из зоны в зону (это мы программируем у клиента). Команду мы тоже определяем стартовую и впоследствии можем менять (add\_actor\_to\_team, remove\_actor\_from\_team). Каждому персонажу и объекту может соответствовать пользовательский сценарий (он активируется при нажатии мышкой на объект). Сценарий может включать диалог, взятие предмета, добавление персонажа в команду, квест и т.д.
Зона тоже может содержать сценарий, который запускается когда команда попадает в зону.
Клиентский класс (BGGame) также содержит глобальные переменные, определяющие ситуации в игре (например квесты). Локальные переменные могут быть в зоне.

Как программируются зоны. Если нужны локальные переменные (состояние локальных событий), то тогда нужно создавать класс своей зоны как наследник от Area. Или же просто использовать класс Area. Добавляем зону в игру new\_area(name, area). Переключаем зону - set\_area(name). Глобальные сценарии находятся в классе игры (BGGame), мы подключаем их как :
Area.set\_enter\_script(script)
В зону мы добавляем персонажей и предметы как add\_object(x,y, obj) - z не нужно, так как слой можно определить по y координате.
В конкретную зону мы добавляем сценарий для взаимодействия как: Game.game.start\_script(script, name)
Как происходит переход команды между зонами.
В зоне определяем объект дверь, по клику мыши она может открываться и закрываться (меняется состояние объекта). Назначаем сценарий walk\_script(script), который срабатывает когда кто-то из команды пересекает объект. В этом сценарии мы меняем зону на нужную (set\_area), и устанавливаем команду в нужную позицию (set\_team). В другой зоне делается аналогично, только переход и позиция будут другими.
Сценарии - это потоки которые запускаются параллельно (метод RPGGame.start\_script(script)). Сценарий может быть остановлен (stop\_script(name)).
Таким образом, мир будет интерактивным.
Как связано окно и графика с игрой. В окне мы делаем таймер, который вызывает метод update нашей игры (BGGame). Этот метод выполняет все действия объектов в игре за 1 кадр времени.
Также в таймере вызываем Graphics.update(), который обновляет графику игры.
Все объекты (Actor, Item) должны иметь состояния (как минимум одно). Каждое состояние связано с спрайтом (или анимацией). То есть переключение состояния меняет графику объекта.

А вообще сценарии и глобальные переменные могут быть без классов, а просто в модулях, так проще, чтобы к ним был доступ из всех комнат. Тогда и функции движка должны быть доступны везде (то есть во всех сценариях). Например делаем модуль руины (ruins):
import random
from math import sqrt
import time
from rpg.area import *
from rpg.sprite import *
from rpg.rectangle import *
from rpg.game import Game
from rpg.portal import Portal

class Ruins(Area):
def \_\_init\_\_(self):
'''
Класс игровой зоны Ruins

'''
super().\_\_init\_\_()
self.add\_sprite(Sprite('images/fon3.png'), 590, 400, 0)
self.add\_rect(Rectangle(x=0, y=0, width=Sprite('images/fon3.png').image.width(), height=Sprite('images/fon3.png').image.height()))
from grunt import Grunt
self.grunt = Grunt(0,0,0)
from footman import Footman
self.footman = Footman(0,0,0)
self.add\_object(self.footman, 120, 120, 1)
self.add\_object(self.grunt, 500, 185, 1)
p = Portal(400, 400, 200, 200, 'Village', 480, 100)
self.add\_object(p, p.pos\_x, p.pos\_y, 100)
Game.game.start\_script(self.ai, "ai", self.grunt)
Game.game.start\_script(self.walk\_two, "footman", 50, 50)


def walk(self, step\_x, step\_y, actor):
'''
Сценарий для движения бугая

:param step\_x: шаг движения x
:param step\_y: шаг движения y
'''
if actor.hp <= 0:
Game.game.stop\_script("grunt")
new\_x = 200
new\_y = 200
actor.is\_attack = False
direction = random.choice(["up", "down", "left", "right"])
if direction == "up":
new\_y -= step\_y
new\_x = step\_x
elif direction == "down":
new\_y += step\_y
new\_x = step\_x
elif direction == "left":
new\_y = step\_y
new\_x -= step\_x
elif direction == "right":
new\_y = step\_y
new\_x += step\_x

actor.search\_position(new\_x, new\_y)

time.sleep(2)

модуль bggame:
from ruins import *
import time
import random

class BaldursGame(Game):
def \_\_init\_\_(self, canvas, window, **params):
'''
Класс конкретной игры для демонстрации

:param canvas: класс графической системы
:param window: окно на которое будет выводится игра
'''
super().\_\_init\_\_(canvas, window, **params)
from mage import Mage
self.add\_pc\_to\_team(Mage(0, 0, 0))
self.new\_area('Ruins', Ruins())
self.set\_area('Ruins')
self.set\_team(500, 300, 100)
self.timer()

\subsubsection{Пример клиентского кода игры}
\paragraph{Cоздание классов персонажей/предметов}
Клиент создает модуль содержащий методы модуля RPGGame, например BaldursGateGame. В этом модуле клиент создаем мир игры, с помощью new\_actor. 

модуль bggame:
from ruins import *
import time
import random

class BaldursGame(Game):
def \_\_init\_\_(self, canvas, window, **params):
'''
Класс конкретной игры для демонстрации

:param canvas: класс графической системы
:param window: окно на которое будет выводится игра
'''
super().\_\_init\_\_(canvas, window, **params)
from mage import Mage
self.add\_pc\_to\_team(Mage(0, 0, 0))
self.new\_area('Ruins', Ruins())
self.set\_area('Ruins')
self.set\_team(500, 300, 100)
self.timer()

\paragraph{Задание правил атаки}
Пользователь создаёт класс ADnDActor, наследник от класса Actor в своём модуле bggame, в нём он прописывает свои правила по которым происходит атака. То есть Actor.attack(self, actor), где actor - кого атакуют.
Пример:

модуль adnd\_actor:
from math import sqrt
from rpg.actor import Actor
from rpg.animation import Animation
import rpg.game
import time

class Adnd\_actor(Actor):

ATTACK\_RANGE = 50

def \_\_init\_\_(self, x, y, z, **params):
'''
Класс Adnd\_actor содержащий основные механики взаимодействия с другими персонажами

:param x: координата x
:param y: координата y
:param z: координата z
'''
super().\_\_init\_\_(x, y, z, **params)
self.on\_click = self.click

def click(self):
'''
вызывается при клике на персонажа

'''
pc = rpg.game.Game.game.team\_of\_pc[0]
if pc == self:
return
dx = pc.pos\_x - self.pos\_x
dy = pc.pos\_y - self.pos\_y
dist = sqrt(dx * dx + dy * dy)
if dist <= self.ATTACK\_RANGE:
pc.is\_attack = True
pc.attack(self)
time.sleep(0.125)
if self.hp <=0:
pc.is\_attack = False

def attack(self, actor):
'''
совершает атаку по actor

:param actor: персонаж, которого атакуют
'''
actor.hp -= self.damage
def update(self):
'''
обновляет состояние персонажа

'''
super().update()
if self.hp <= 0:
self.stop\_move()
self.set\_state('death')


\paragraph{Создание зон, заполнение их персонажами/объектами}
Мир также состоит из зон (Area). Каждая зона включает в себя графику, персонажи и предметы и сценарии взаимодействия. Исключение составляет команда PC, которая может перемещаться из зоны в зону (это мы программируем у клиента). Как программируются зоны. Если нужны локальные переменные (состояние локальных событий), то тогда нужно создавать класс своей зоны как наследник от Area. Или же просто использовать класс Area. Добавляем зону в игру new\_area(name, area). Переключаем зону - set\_area(name). Так же требуется задать область движения, её проще сделать как совокупность прямоугольников, за которые персонажи не могут выйти. Эти прямоугольники должны касаться друг друга, но не пересекаться. Тогда алгоритм проверки выхода несложный: выход за пределы области только тогда, когда прямоугольник персонажа пересек сторону (одну или две) одного из прямоугольников области, эта сторона не является касательной.

import random
from math import sqrt
import time
from rpg.area import *
from rpg.sprite import *
from rpg.rectangle import *
from rpg.game import Game
from rpg.portal import Portal

class Ruins(Area):
def \_\_init\_\_(self):
'''
Класс игровой зоны Ruins

'''
super().\_\_init\_\_()
self.add\_sprite(Sprite('images/fon3.png'), 590, 400, 0)
self.add\_rect(Rectangle(x=0, y=0, width=Sprite('images/fon3.png').image.width(), height=Sprite('images/fon3.png').image.height()))
from grunt import Grunt
self.grunt = Grunt(0,0,0)
from footman import Footman
self.footman = Footman(0,0,0)
self.add\_object(self.footman, 120, 120, 1)
self.add\_object(self.grunt, 500, 185, 1)
p = Portal(400, 400, 200, 200, 'Village', 480, 100)
self.add\_object(p, p.pos\_x, p.pos\_y, 100)
Game.game.start\_script(self.ai, "ai", self.grunt)
Game.game.start\_script(self.walk\_two, "footman", 50, 50)


def walk(self, step\_x, step\_y, actor):
'''
Сценарий для движения бугая

:param step\_x: шаг движения x
:param step\_y: шаг движения y
'''
if actor.hp <= 0:
Game.game.stop\_script("grunt")
new\_x = 200
new\_y = 200
actor.is\_attack = False
direction = random.choice(["up", "down", "left", "right"])
if direction == "up":
new\_y -= step\_y
new\_x = step\_x
elif direction == "down":
new\_y += step\_y
new\_x = step\_x
elif direction == "left":
new\_y = step\_y
new\_x -= step\_x
elif direction == "right":
new\_y = step\_y
new\_x += step\_x

actor.search\_position(new\_x, new\_y)

time.sleep(2)

модуль bggame:
from ruins import *
import time
import random

\paragraph{Пример сценариев: переход между зонами}
Глобальные сценарии находятся в классе игры (BGGame), мы подключаем их как :
Area.set\_enter\_script(script)
Как происходит переход команды между зонами.
В зоне определяем объект портал, по клику мыши когда персонаж заходит внутрь портала срабатывает self.actor\_in(self, actor). При создании портала, мы указываем кудаи в какую зону разместить команду персонажей.

from rpg.object import Object
from rpg.game import Game
from rpg.rectangle import Rectangle

class Portal(Object):
def \_\_init\_\_(self, x, y, width, height, area, team\_x, team\_y):
''' 
Создает портал в новую зону

:param x: координата x портала
:param y: координата y портала
:param width: ширина портала
:param height: высота портала
:param area: имя зоны куда будет переход
:param team\_x: местоположение команды в новой зоне
:param team\_y: местоположение команды в новой зоне
'''
self.states = None
self.sprite = None
self.category = 'portal'
super().\_\_init\_\_(x, y, 0)
self.rectangle = Rectangle(x, y, width, height)
self.area = area
self.team\_x = team\_x
self.team\_y = team\_y
self.visible = False

def actor\_in(self, actor):
'''
Проверяет находится ли персонаж внутри портала

:param actor: проверяемый персонаж
'''
if actor.category == "pc":
Game.game.set\_area(self.area)
Game.game.set\_team(self.team\_x, self.team\_y, 100)
actor.stop\_move()

модуль ruins
import random
from math import sqrt
import time
from rpg.area import *
from rpg.sprite import *
from rpg.rectangle import *
from rpg.game import Game
from rpg.portal import Portal

class Ruins(Area):
def \_\_init\_\_(self):
'''
Класс игровой зоны Ruins

'''
super().\_\_init\_\_()
self.add\_sprite(Sprite('images/fon3.png'), 590, 400, 0)
self.add\_rect(Rectangle(x=0, y=0, width=Sprite('images/fon3.png').image.width(), height=Sprite('images/fon3.png').image.height()))
from grunt import Grunt
self.grunt = Grunt(0,0,0)
from footman import Footman
self.footman = Footman(0,0,0)
self.add\_object(self.footman, 120, 120, 1)
self.add\_object(self.grunt, 500, 185, 1)
p = Portal(400, 400, 200, 200, 'Village', 480, 100)

\paragraph{Как будет идти бой}
Бой будет совершаться с помощью сценариев. У класса Adnd\_actor есть метод attack(self, actor), который уменьшает текущее количество здоровья у actor. В модуле game существуют методы start\_script(script, name), stop\_script(name). С помощь сценариев возможно запускать параллельные потоки. В конкретную зону будет добавляться сценарий 'ai', в который передаётся конкретный персонаж. В этом сценарии указывается поведение противника, Что он должен сближаться с персонажем игрока, и когда расстояние до атаки будет достаточным, чтобы её совершить, будет вызван метод actor.attack. Для того, чтобы пользователь мог атаковать персонажа, у каждого экземпляра класса adnd\_actor есть метод click(self), который вызывает проверку условия, если персонаж близко к персонажу игрока, хранящемуся в rpg.game.Game.team\_of\_pc, то вызвать у pc=rpg.game.Game.team\_of\_pc[0], attack(self)/
Пример:
модуль adnd\_actor:
from math import sqrt
from rpg.actor import Actor
from rpg.animation import Animation
import rpg.game
import time

class Adnd\_actor(Actor):

ATTACK\_RANGE = 50

def \_\_init\_\_(self, x, y, z, **params):
'''
Класс Adnd\_actor содержащий основные механики взаимодействия с другими персонажами

:param x: координата x
:param y: координата y
:param z: координата z
'''
super().\_\_init\_\_(x, y, z, **params)
self.on\_click = self.click

def click(self):
'''
вызывается при клике на персонажа

'''
pc = rpg.game.Game.game.team\_of\_pc[0]
if pc == self:
return
dx = pc.pos\_x - self.pos\_x
dy = pc.pos\_y - self.pos\_y
dist = sqrt(dx * dx + dy * dy)
if dist <= self.ATTACK\_RANGE:
pc.is\_attack = True
pc.attack(self)
time.sleep(0.125)
if self.hp <=0:
pc.is\_attack = False

def attack(self, actor):
'''
совершает атаку по actor

:param actor: персонаж, которого атакуют
'''
actor.hp -= self.damage
def update(self):
'''
обновляет состояние персонажа

'''
super().update()
if self.hp <= 0:
self.stop\_move()
self.set\_state('death')

модуль ruins
import random
from math import sqrt
import time
from rpg.area import *
from rpg.sprite import *
from rpg.rectangle import *
from rpg.game import Game
from rpg.portal import Portal

class Ruins(Area):
def \_\_init\_\_(self):
'''
Класс игровой зоны Ruins

'''
super().\_\_init\_\_()
self.add\_sprite(Sprite('images/fon3.png'), 590, 400, 0)
self.add\_rect(Rectangle(x=0, y=0, width=Sprite('images/fon3.png').image.width(), height=Sprite('images/fon3.png').image.height()))
from grunt import Grunt
self.grunt = Grunt(0,0,0)
from footman import Footman
self.footman = Footman(0,0,0)
self.add\_object(self.footman, 120, 120, 1)
self.add\_object(self.grunt, 500, 185, 1)
p = Portal(400, 400, 200, 200, 'Village', 480, 100)
self.add\_object(p, p.pos\_x, p.pos\_y, 100)
Game.game.start\_script(self.ai, "ai", self.grunt)
Game.game.start\_script(self.walk\_two, "footman", 50, 50)


def walk(self, step\_x, step\_y, actor):
'''
Сценарий для движения бугая

:param step\_x: шаг движения x
:param step\_y: шаг движения y
'''
if actor.hp <= 0:
Game.game.stop\_script("grunt")
new\_x = 200
new\_y = 200
actor.is\_attack = False
direction = random.choice(["up", "down", "left", "right"])
if direction == "up":
new\_y -= step\_y
new\_x = step\_x
elif direction == "down":
new\_y += step\_y
new\_x = step\_x
elif direction == "left":
new\_y = step\_y
new\_x -= step\_x
elif direction == "right":
new\_y = step\_y
new\_x += step\_x

actor.search\_position(new\_x, new\_y)

def ai(self, actor):
'''
скрипт противников

:param step\_x: размер шага x до персонажа игрока
:param step\_y: размер шага x до персонажа игрока
:param actor: персонаж противник
'''
if actor.hp <= 0:
Game.game.stop\_script("ai")
import rpg.game
pc = rpg.game.Game.game.team\_of\_pc[0]
new\_x = pc.pos\_x
new\_y = pc.pos\_y

actor.search\_position(new\_x, new\_y)
dx = pc.pos\_x - actor.pos\_x
dy = pc.pos\_y - actor.pos\_y
dist = sqrt(dx * dx + dy * dy)
if dist <= actor.ATTACK\_RANGE:
actor.is\_attack = True
actor.attack(pc)
time.sleep(1)
if pc.hp <=0:
actor.update()
Game.game.stop\_script("ai")
Game.game.start\_script(self.walk, "grunt", 50, 50, actor)

else:
actor.is\_attack = False
time.sleep(2)

\paragraph{Соединение движка и окон tkinter}
Модуль graphics содержит в себе библиотеку tkinter . Класс Graphics внутри модуля является наследником tk.Canvas. Этот класс взаимодействует с окном root = tk.TK() в программном модуле пользователя. Модуль sprite тоже взаимодействует с tkinter. Изображение для спрайта берётся с помощью метода tk.PhotoImage(file=name)

модуль sprite

import tkinter as tk
class Sprite:

def \_\_init\_\_(self, image):
'''
Класс спрайта для работы с изображениями на Canvas

:param image: адресс изображения который
'''
self.image = tk.PhotoImage(file=image)
self.tag = None
self.x = 0
self.y = 0
self.z = 0

def set\_tag(self, tag):
'''
Устанавливает тег спрайта

:param tag: тег спрайта
'''
self.tag = tag

def set\_z(self, z):
'''
Устанавливает z-координату спрайта

:param z: координата z
'''
self.z = z

def get\_tag(self):
'''
Возвращает тег спрайта

'''
return self.tag

def set\_coords(self, new\_x, new\_y):
'''
Обновляет координаты спрайта

:param new\_x: координата x
:param new\_y: координата y
'''
if self.tag:
self.x = new\_x
self.y = new\_y
def update(self):
'''
Обновляет анимацию спрайта

'''
pass

модуль graphics

import tkinter as tk

class Graphics(tk.Canvas):
canvas = None
def \_\_init\_\_(self, master, **kwargs):
'''
Класс с методами для работы со спрайтами

'''
super().\_\_init\_\_(master, **kwargs)
self.sprites = []  # список спрайтов
Graphics.canvas = self

def add\_sprite(self, sprite, x, y, z, **kwargs):
'''
Добавляет спрайт на Canvas

:param sprite: спрайт
:param x: координата x
:param y: координата y
:param z: координата z
:param kwargs: параметры относящиеся к конкретному изображению в tkinter
'''
tag = self.create\_image(x, y, image=sprite.image, anchor='center', **kwargs)
sprite.set\_tag(tag)
sprite.set\_z(z)
sprite.x = x
sprite.y = y
self.sprites.append(sprite)
self.sprites.sort(key=lambda sprite: sprite.z)

def update(self):
'''
Перерисовывает все спрайты

'''
for sprite in self.sprites:
sprite.update()
self.tag\_raise(sprite.get\_tag())
self.coords(sprite.get\_tag(), sprite.x, sprite.y)
self.itemconfig(sprite.get\_tag(), image=sprite.image)


def change\_sprite(self, sprite, new\_sprite):
'''
Меняет  спрайт на новый.

:param sprite: экземпляр спрайта
:param new\_sprite: новый спрайт
'''
old\_sprite\_pos = None
for i, s in enumerate(self.sprites):
if s.get\_tag() == sprite.get\_tag():
old\_sprite\_pos = i
break

if old\_sprite\_pos is not None:
old\_tag = sprite.get\_tag()

self.sprites[old\_sprite\_pos] = new\_sprite
new\_sprite.set\_tag(old\_tag)

new\_sprite.set\_tag(old\_tag)
new\_sprite.set\_z(sprite.z)

self.tag\_raise(old\_tag)
self.coords(old\_tag, sprite.x, sprite.y)
self.itemconfig(old\_tag, image=new\_sprite.image)

def delete\_sprite(self, sprite):
'''
Удаляет спрайт с Canvas.

:param sprite: экземпляр спрайта
:return:
'''
self.delete(sprite.get\_tag())
self.sprites.remove(sprite)

def clear\_all(self):
'''
Удаляет все спрайты с Canvas

'''
for sprite in self.sprites:
self.delete(sprite.get\_tag())
self.sprites.clear()

модуль baldursgame '''пользовательский модуль'''

from ruins import *
from village import *
import time
import random

class BaldursGame(Game):
def \_\_init\_\_(self, canvas, window, **params):
'''
Класс конкретной игры для демонстрации

:param canvas: класс графической системы
:param window: окно на которое будет выводится игра
'''
super().\_\_init\_\_(canvas, window, **params)
from mage import Mage
self.add\_pc\_to\_team(Mage(0, 0, 0))
self.new\_area('Ruins', Ruins())
self.new\_area('Village', Village())
self.set\_area('Ruins')
self.set\_team(500, 300, 100)
self.timer()

модуль main
from bggame import *

root = tk.Tk()
root.geometry('1500x1500')

exit\_button = tk.Button(root, text="Exit", fg="red", command=root.destroy)
canvas = Graphics(root, width=1500, height=1500)
Graphics.canvas = canvas

BaldursGame(canvas, root)

canvas.place(height = 1500, width =1500)
BaldursGame.timer

root.mainloop()


\subsection{Модули и классы}
\subsection{Game}
\subsubsection{Описание модуля}
\paragraph{Конструктор и поля модуля}
def \_\_init\_\_(self,  canvas, window, **params) 
\begin{itemize} 
	\item self.rpg\_dict\_of\_area = {} 
	\item словарь, хранящий в себе множество экземпляров класса Area, {number - ключ : name Area - значение}
	\item self.team\_of\_pc = [] 
	\item список, хранящий в себе имена экземпляров класса Actor с параметром category = "pc"
	\item self.canvas = canvas 
	\item графика
	\item self.root = window 
	\item окно для графики
	\item self.current\_area = None 
	\item параметр хранящий, текущую зону
	\item self.scripts = {}  
	\item Словарь для хранения запущенных сценариев
	\item self.events = {} 
	\item Словарь для хранения запущенных event`ов сценариев
	\item self.canvas.bind("<Button-1>", self.mouse\_left\_click)
	\item обработчик клика
	\item Game.game = self
	\item экземпляр игры, для обращения к нему напрямую
\end{itemize}
\subsubsection{Методы}
\paragraph{New\_area}
def new\_area(self, name, area)
Описание метода: Добавляет новую зону в список.
\paragraph{Set\_area}
def set\_area(self, name)
Описание метода: Устанавливает текущую зону, загружает графику зоны.
\paragraph{New\_actor}
def new\_actor(self, name, **params)
Описание метода: метод отвечающий за создание класса, потомка от Actor и создание поля из параметров, и установление их в начальные значения.
\paragraph{Start\_script}
def start\_script(self, script\_function, script\_name, *args)
Описание метода: Запускает сценарий в отдельном потоке с возможностью остановки и передачи аргументов.
\paragraph{Stop\_script}
def stop\_script(self, script\_name)
Описание метода: Останавливает сценарий по имени.
\paragraph{Add\_pc\_to\_team}
def add\_pc\_to\_team(self, pc)
Описание метода: метод отвечающий за добавление имени экземпляра класса Actor с параметром category = "pc" в список team\_of\_pc, хранящий имена всех игровых персонажей.
\paragraph{Remove\_pc\_from\_team}
def remove\_pc\_from\_team(self, pc)
Описание метода: метод отвечающий за удаление имени экземпляра класса Actor с параметром category = "pc" в список team\_of\_pc, хранящий имена всех игровых персонажей.
\paragraph{Set\_team}
def set\_team(self, x, y, z)
Описание метода: Устанавливает координаты персонажей команды.
\paragraph{Update}
def update(self)
Описание метода: Вызывается в таймере для обновления всех переменных в текущей зоне.
\paragraph{Mouse\_left\_click}
def mouse\_left\_click(self, event)
Описание метода: обрабатывает клик мыши.
\paragraph{Timer}
def timer(self)
Описание метода: Таймер дожен вызывать метод update постоянно.


\subsection{Area}
\subsubsection{Описание модуля}
\paragraph{Конструктор и поля модуля}
def \_\_init\_\_(self, **params)
\begin{itemize}
	\item self.area\_zone = params 
	\item параметр определяющий особенности конкретной зоны
	\item self.objects = [] 
	\item список, хранящий в себе множество экземпляров классов Item
	\item self.sprites = [] 
	\item список фоновых спрайтов
	\item self.rectangles = None 
	\item список, хранящий в себе множетво прямоугольников
\end{itemize}
\subsubsection{Методы}
\paragraph{Add\_sprite}
def add\_sprite(self, sprite, x, y, z)
Описание метода: Добавляет спрайт в зону.
\paragraph{Add\_object}
def add\_object(self, obj, x, y, z)
Описание метода: Добавляет объект в зону.
\paragraph{Remove\_object}
def remove\_object(self, obj)
Описание метода: Удаляет объект из зоны.
\paragraph{Load\_sprites}
def load\_sprites(self)
Описание метода: Загружает все спрайты зоны.
\paragraph{Add\_rect}
def add\_rect(self, rec)
Описание метода: Добавляет прямоугольник в зону.
\paragraph{Entry\_script}
def entry\_script(self))
Описание метода: Запускается, когда команда входит в зону.
\paragraph{Exit\_script}
def exit\_script(self)
Описание метода: Запускается, когда команда выходит из зоны.
\paragraph{Update}
def update(self)
Описание метода: Изменяет и проверяет изменение всех персонажей в зоне.

\subsection{Sprite}
\subsubsection{Описание модуля}
\paragraph{Конструктор и поля модуля}
def \_\_init\_\_(self, image)
\begin{itemize}
	\item self.spr\_image = image
	\item Описание параметра: параметр хранит изображение конкретного экземпляра класса Sprite.
	\item self.tag = None
	\item self.spr\_x = x
	\item Описание параметра: параметр хранит числовое значение обозначающее расположение конкретного экземпляра класса Sprite.
	\item self.spr\_y = y
	\item Описание параметра: параметр хранит числовое значение обозначающее расположение конкретного экземпляра класса Sprite.
	\item self.spr\_z = z
	\item Описание параметра: параметр хранит числовое значение обозначающее расположение конкретного экземпляра класса Sprite.
\end{itemize}
\subsubsection{Методы}
\paragraph{Set\_tag}
def set\_tag(self, tag)
\paragraph{Set\_z}
def set\_z(self, z)
\paragraph{Get\_tag}
def get\_tag(self)
\paragraph{Set\_coords}
def set\_coords(self, new\_x, new\_y)
\paragraph{Update}
def update(self)
\subsection{Graphics}
\subsubsection{Описание модуля}
\paragraph{Конструктор и поля модуля}
def \_\_init\_\_(self, master, **kwargs)
\begin{itemize}
	\item super().\_\_init\_\_(master, **kwargs)
	\item self.sprites = [] 
	\item список спрайтов
	\item Graphics.canvas = self
	\item параметр для работы с графикой, где к ней нужно обращаться напрямую
\end{itemize}
\subsubsection{Методы}
\paragraph{Add\_sprite}
def add\_sprite(self, sprite, x, y, z, **kwargs)
Описание метода: Добавляет спрайт на Canvas
\paragraph{Update}
def update(self)
Описание метода: Перерисовывает все спрайты
\paragraph{Change\_sprite}
def change\_sprite(self, sprite, new\_sprite)
Описание метода: Меняет  спрайт на новый
\paragraph{Delete\_sprite}
def delete\_sprite(self, sprite)
Описание метода: Удаляет спрайт с Canvas
\paragraph{Clear\_all}
def clear\_all(self)
Описание метода: Удаляет все спрайты с Canvas

\subsection{Animation(Sprite)}
\subsubsection{Описание модуля}
\paragraph{Конструктор и поля модуля}
def \_\_init\_\_(self, frames, cycle=True)
\begin{itemize}
	\item super().\_\_init\_\_(frames[0])
	\item self.images = frames
	\item Описание параметра: """список кадров"""
	\item self.current\_frame = 0
	\item self.images = [tk.PhotoImage(file=frame) for frame in frames]   
	\item Загрузка всех кадров анимации
	\item self.image = self.images[0]
	\item Установка начального изображения
	\item self.speed = 3
	\item Описание параметра: """скорость анимации"""
	\item self.counter = self.speed
	\item self.cycle = cycle
	\item self.running = True
\end{itemize}
\subsubsection{Методы}
\paragraph{Update:}
def update(self):
Меняет текущее изображение в списке изображений.

\subsection{Object}
\subsubsection{Описание модуля}
\paragraph{Конструктор и поля модуля}
def \_\_init\_\_(self, x, y, z, **params)
\begin{itemize}
	\item self.pos\_x = x
	\item координата x
	\item self.pos\_y = y
	\item координата y
	\item self.pos\_z = z
	\item координата z
	\item self.current\_state = None
	\item текущее состояние
	\item self.visible = True
	\item видим ли объект
	\item self.on\_click = lambda x : x
	\item возможно ли кликнуть по объекту
	\item if self.states is not None:
	self.set\_state(next(iter(self.states)))  # Установка первого состояния
	\item установка первого состояния если потребуется
	\item self.rectangle = Rectangle(x, y, 10, 10) # из спрайта
	\item прямоугольник объекта
\end{itemize}
\subsubsection{Методы}
\paragraph{Set\_state}
def set\_state(self, state\_name):
Описание метода: меняет текущее состояние объекта
\paragraph{Actor\_in}
 def actor\_in(self, actor):
Описание метода:Вызывается когда actor входит внутрь объекта
\paragraph{Update}
def update(self)
Описание метода: ничего не делает

\subsection{Actor(Object)}
\subsubsection{Описание модуля}
\paragraph{Конструктор и поля модуля}
def \_\_init\_\_(self, x, y, z, **params)
\begin{itemize}
	\item self.sprite = self.states[next(iter(self.states))]
	\item параметр хранящий спрайт
	\item super().\_\_init\_\_(x, y, z, **params)
	\item self.speed\_x = 0 
	\item значение скорости x
	\item self.speed\_y = 0  
	\item значение скорости y
	\item self.target\_x = 0
	\item координата x в которую будет двигаться персонаж
	\item self.target\_y = 0
	\item координата y в которую будет двигаться персонаж
	\item self.rectangle = Rectangle(self.pos\_x, self.pos\_y, self.sprite.image.width(), self.sprite.image.height())
	\item прямоугольник персонажа
	\item self.is\_attack = False
	\item состояние - атакует ли персонаж сейчас
\end{itemize}
\subsubsection{Методы}
\paragraph{update}
def update(self)
Описание метода: изменяет координаты и состояние персонажа.
\paragraph{Search\_position}
def search\_position(self, new\_x, new\_y)
Описание метода:  Изменяет направление движения у персонажа.
\paragraph{Stop\_move}
def stop\_move(self):
Описание метода: Останавливает движение персонажа.

\subsection{Adnd\_actor(Actor)}
\subsubsection{Описание модуля}
\paragraph{Конструктор и поля модуля}
def \_\_init\_\_(self, x, y, z, **params)
\begin{itemize}
	\item super().\_\_init\_\_(x, y, z, **params)
	\item self.on\_click = self.click
	\item событие по клику на персонажа
\end{itemize}
\subsubsection{Методы}
\paragraph{Click}
def click(self)
Описание метода: вызывается при клике на персонажа.
\paragraph{Attack}
def attack(self, actor)
Описание метода: совершает атаку по actor.
\paragraph{Update}
def update(self)
Описание метода: обновляет состояние персонажа.

\subsection{Rectangle}
\subsubsection{Описание модуля}
\paragraph{Конструктор и поля модуля}
def \_\_init\_\_(self, x, y, width, height)
\begin{itemize}
	\item self.x = x
	\item координата x прямоугольника
	\item self.y = y
	\item координата y прямоугольника
	\item self.width = width
	\item ширина прямоугольника
	\item self.height = height
	\item высота прямоугольника
\end{itemize}
\subsubsection{Методы}
\paragraph{Is\_in}
def is\_in(self, rect)
Описание метода: Проверяет, входит ли прямоугольник self в прямоугольник rect
\paragraph{Is\_point\_inside}
def is\_point\_inside(self, target\_x, target\_y)
Описание метода: Проверяет, входит ли точка (x, y) в данный прямоугольник

\subsection{Portal(Object)}
\subsubsection{Описание модуля}
\paragraph{Конструктор и поля модуля}
def \_\_init\_\_(self, x, y, width, height, area, team\_x, team\_y)
\begin{itemize}
	\item self.states = None
	\item состояние портала
	\item self.sprite = None
	\item спрайт портала
	\item self.category = 'portal'
	\item категория портала
	\item super().\_\_init\_\_(x, y, 0)
	\item self.rectangle = Rectangle(x, y, width, height)
	\item прямоугольник портала
	\item self.area = area
	\item текущая зона
	\item self.team\_x = team\_x
	\item координата x в новой зоне в которую установят команду
	\item self.team\_y = team\_y
	\item координата y в новой зоне в которую установят команду
	\item self.visible = False
	\item видимость портала
\end{itemize}
\subsubsection{Методы}
\paragraph{Actor\_in}
def actor\_in(self, actor)
Описание метода: Проверяет находится ли персонаж внутри портала

