\section{Технический проект}
\subsection{Общая характеристика организации решения задачи}

Необходимо спроектировать и разработать приложение, который должен способствовать популяризации ролевых игр.

Приложение представляет собой набор взаимосвязанных различных окон, которые сгруппированы по разделам, содержащие текстовую, графическую информацию. Приложение располагается на компьютере.

\subsection{Обоснование выбора технологии проектирования}

На сегодняшний день информационный рынок, поставляющий программные решения в выбранной сфере, предлагает множество продуктов, позволяющих достигнуть поставленной цели – разработки приложения.

\subsubsection{Описание используемых технологий и языков программирования}

В процессе разработки приложения используются программные средства и языки программирования. Каждое программное средство и каждый язык программирования применяется для круга задач, при решении которых они необходимы.

\subsubsection{Язык программирования Python}

Python –  высокоуровневый язык программирования общего назначения с динамической строгой типизацией и автоматическим управлением памятью, ориентированный на повышение производительности разработчика, читаемости кода и его качества, а также на обеспечение переносимости написанных на нём программ. Язык является полностью объектно-ориентированным в том плане, что всё является объектами. Необычной особенностью языка является выделение блоков кода отступами. Синтаксис ядра языка минималистичен, за счёт чего на практике редко возникает необходимость обращаться к документации. Сам же язык известен как интерпретируемый и используется в том числе для написания скриптов. Недостатками языка являются зачастую более низкая скорость работы и более высокое потребление памяти написанных на нём программ по сравнению с аналогичным кодом, написанным на компилируемых языках, таких как C или C++.

\subsubsection{Язык программирования Python}

\paragraph{Достоинства языка Python}
\begin{itemize}
	\item Простота и читаемость кода: Python использует простой и чистый синтаксис, что делает код легким для понимания и обслуживания.
	\item Многофункциональность: Python подходит для создания различных типов приложений, включая веб-приложения, настольные приложения, научные вычисления, обработку данных и многое другое
	\item Большой выбор библиотек: Python имеет огромное сообщество разработчиков, что приводит к большому количеству библиотек и модулей для различных задач. Например, для машинного обучения есть библиотека TensorFlow, для веб-разработки - Django, для анализа данных - Pandas и многое другое.
	\item Кроссплатформенность: Python работает на различных операционных системах, таких как Windows, macOS, Linux и другие.
	\item Быстрая разработка: Python позволяет быстро создавать прототипы и тестировать идеи благодаря своей простоте и мощности.
\end{itemize}

\paragraph{Недостатки языка Python}

\begin{itemize}
	\item Низкая производительность: Python может быть медленнее других языков программирования, таких как C++ или Java, особенно при выполнении вычислительно сложных операций.
	\item Глобальная блокировка интерпретатора: из-за глобальной блокировки GIL (Global Interpreter Lock) в Python, многопоточные приложения могут испытывать проблемы с параллельным выполнением кода.
	\item Не самый подходящий для мобильной разработки: Python не является первым выбором для мобильной разработки из-за ограниченной поддержки на мобильных платформах.
	\item Не все библиотеки могут быть на Python: Так как Python находится в постоянном развитии, не все библиотеки могут быть доступны на этом языке.
	\item Меньшая поддержка для некоторых областей разработки, таких как игровая разработка или высокопроизводительные вычисления.
\end{itemize}

\subsubsection{Использование библиотеки Tkinter и реализация таймеров на Python}
	
\paragraph{Введение}
Библиотека Tkinter - это стандартная библиотека Python для создания графического пользовательского интерфейса (GUI). Она обладает широкими возможностями для создания разнообразных приложений с использованием различных виджетов, таких как кнопки, поля ввода, метки и многое другое.
	
\paragraph{Возможности Tkinter}
Вот некоторые из основных возможностей, предоставляемых библиотекой Tkinter:
	
\begin{itemize}
	\item Создание различных виджетов: кнопки, метки, поля ввода, списки и многое другое.
	\item Управление компоновкой виджетов с использованием менеджеров компоновки (например, grid, pack, place).
	\item Обработка событий, таких как щелчок мыши, нажатие клавиш и другие.
	\item Возможность создания различных диалоговых окон, таких как окна предупреждений, информационные окна и окна запроса.
	\item Поддержка многопоточности для обновления интерфейса из различных потоков выполнения.
\end{itemize}
	
\paragraph{Реализация таймеров на Python}
Для реализации таймеров на Python можно использовать модуль \texttt{time} или \texttt{threading}. Вот пример использования модуля \texttt{time} для создания простого таймера:
	
	import time
	
	def countdown(t):
	while t > 0:
	mins, secs = divmod(t, 60)
	timeformat = '{:02d}:{:02d}'.format(mins, secs)
	print(timeformat, end='\r')
	time.sleep(1)
	t -= 1
	print('Таймер завершен!')
	
	\# Установка времени для таймера (в секундах)
	t = 10
	countdown(t)
	
Этот код создает простой обратный отсчет таймера с использованием функции \texttt{countdown}. Он выводит оставшееся время в формате ММ:СС и уменьшает его на 1 каждую секунду, используя функцию \texttt{time.sleep(1)}. Когда время истекает, выводится сообщение о завершении таймера.
	
\paragraph{Заключение}
Библиотека Tkinter предоставляет мощные инструменты для создания графических пользовательских интерфейсов на языке Python. Реализация таймеров на Python может быть достигнута с помощью модулей \texttt{time} или \texttt{threading}, в зависимости от конкретных требований приложения.

\subsection{Описание платформы для создания RPG игр}
Клиент создает модуль содержащий методы модуля RPGGame, например BaldursGateGame. В этом модуле мы создаем мир игры, с помощью new\_actor, new\_item, new\_spell. Мы можем вызывать их много раз с разными параметрами, или загрузить параметры для этих функций из файла. После чего у нас есть персонажи и предметы. Мир также состоит из зон (Area). Каждая зона включает в себя графику, персонажи и предметы и сценарии взаимодействия. Исключение составляет команда PC, которая может перемещаться из зоны в зону (это мы программируем у клиента). Команду мы тоже определяем стартовую и впоследствии можем менять (add\_actor\_to\_team, remove\_actor\_from\_team). Каждому персонажу и предмету может соответствовать пользовательский сценарий (он активируется при нажатии мышкой на объект). Сценарий может включать диалог, взятие предмета, добавление персонажа в команду, квест и т.д.
Зона тоже может содержать сценарий, который запускается когда команда попадает в зону.
Клиентский класс (BGGame) также содержит глобальные переменные, определяющие ситуации в игре (например квесты). Локальные переменные могут быть в зоне.

Как программируются зоны. Если нужны локальные переменные (состояние локальных событий), то тогда нужно создавать класс своей зоны как наследник от Area. Или же просто использовать класс Area. Добавляем зону в игру new\_area(name, area). Переключаем зону - set\_area(name). Глобальные сценарии находятся в классе игры (BGGame), мы подключаем их как :
Area.set\_enter\_script(script)
В зону мы добавляем персонажей и предметы как add\_object(x,y, obj) - z не нужно, так как слой можно определить по y координате.
На объект мы добавляем сценарий для взаимодействия как: obj.set\_click\_script(script)
Как происходит переход команды между зонами.
В зоне определяем объект дверь, по клику мыши она может открываться и закрываться (меняется состояние объекта). Назначаем сценарий set\_walk\_script(script), который срабатывает когда кто-то из команды пересекает объект. В этом сценарии мы меняем зону на нужную (set\_area), и устанавливаем команду в нужную позицию (set\_team). В другой зоне делается аналогично, только переход и позиция будут другими.
Сценарии - это потоки которые запускаются параллельно (метод RPGGame.start\_script(script)). Сценарий может быть остановлен (stop\_thread).
Таким образом, мир будет интерактивным.
Как связано окно и графика с игрой. В окне мы делаем таймер, который вызывает метод update нашей игры (BGGame). Этот метод выполняет все действия объектов в игре за 1 кадр времени.
Также в таймере вызываем Graphics.update(), который обновляет графику игры.
Все объекты (Actor, Item) должны иметь состояния (как минимум одно). Каждое состояние связано с спрайтом (или анимацией). То есть переключение состояния меняет графику объекта.

А вообще сценарии и глобальные переменные могут быть без классов, а просто в модулях, так проще, чтобы к ним был доступ из всех комнат. Тогда и функции движка должны быть доступны везде (то есть во всех сценариях). Например делаем модуль лес (forest):
from rpg.game import *
from rpg.area import Area
forest = Area()
forest.add\_sprite(0, 0, 0, Sprite("back.jpg"))
sword = Sword(normal: Sprite("sword.jpg"))
forest.add\_object(10, 10, sword)
forest.add\_sprite(0, 0, 0, Sprite("brown.jpg"))
door = Door(normal: Sprite("door.jpg"))
forest.add\_object(50, 50, door)
man = ManNPC(left: Animation("left.jpg"), right: Animation("right.jpg"))
player = PlayerPC(left: Animation("left.jpg"), right: Animation("right.jpg"))
forest.add\_object(100, 100, man)
forest.add\_object(150, 132, player)

def man\_dialog():
...

man.set\_click\_script(man\_dialog)
new\_area("Forest", forest)

lair = Area()
lair.add\_sprite(0, 0, 0, Sprite("green.jpg"))
knife = Knife(normal: Sprite("knife.jpg"))
lair.add\_object(60, 80, knife)
bandit = EnemyNPC(left: Animation("left.jpg"), right: Animation("right.jpg"))
player = PlayerPC(left: Animation("left.jpg"), right: Animation("right.jpg"))
lair.add\_object(100, 100, bandit)
lair.add\_object(50, 50, player)

new\_area("Bandits lair", lair)

модуль bggame:
from rpg.game import *
teampc =()
new\_item("Sword", category: "Weapon", attack: 10)
new\_actor("ManNPC",  ADnDActor, category: "NPC")
new\_actor("Bandit",  ADnDActor, category: "enemy")
new\_actor("PlayerPC" ,ADnDActor, category: "PC")
add\_actor\_to\_team(PlayerPC, teampc)

def walk\_script():
	if (act.x = door.x \&\& act.y = door.y)
		set\_area("Bandits lair")
		put\_team(50, 50)

import forest

set\_area("Forest")
set\_team(teampc, forest, 100, 100)


set\_walk\_script(walk\_script)

import lair


Еще надо определиться, как задать правила AD\&D.
Лучше так: сделать класс ADnDActor (это делает клиент, не движок), где мы перекрываем метод attack, и там программируем формулу расчета повреждения, уменьшаем hp и т.д.
То есть Actor.attack(actor), где actor - кого атакуют
Тогда надо в методе new\_actor указывать еще один параметр - базовый класс, от которого будет наследование.
Пример.
new\_actor("Knight", ADnDActor, category: "enemy", ...)
С магией можно сделать так:
абстрактный класс Spell, где есть метод cast(actor1, actor2), то есть actor1 делает cast на actor2. он изначально пустой. А в new\_spell мы должны указать функцию как именно должен работать Spell (можно прямо как lambda):
new\_spell("Fireball", level:3, class: ["wizard", "priest"], lambda a1,a2 : a2.hp -= 30)
проверку на класс (который требуется) можно изначально сделать в Spell


\subsubsection{Пример клиентского кода игры}
\paragraph{Cоздание классов персонажей/предметов}
Клиент создает модуль содержащий методы модуля RPGGame, например BaldursGateGame. В этом модуле клиент создаем мир игры, с помощью new\_actor, new\_item, new\_spell. 

модуль bggame:
from rpg.game import *
teampc =()
new\_item("Sword", category: "Weapon", attack: 10)
new\_actor("ManNPC", ADnDActor, category: "NPC")
new\_actor("Bandit",  ADnDActor, category: "enemy")
new\_actor("PlayerPC", ADnDActor, category: "PC")
new\_spell("Fireball", level:3, class: ["wizard", "priest"], lambda a1,a2 : a2.hp -= 30)
pc = PlayerPC()
add\_actor\_to\_team(pc)

\paragraph{Задание правил атаки}
Пользователь создаёт класс ADnDActor, наследник от класса Actor в своём модуле bggame, в нём он прописывает свои правила по которым происходит атака. То есть Actor.attack(actor), где actor - кого атакуют
Тогда надо в методе new\_actor указывать еще один параметр - базовый класс, от которого будет наследование.
Пример.

модуль bggame:
from rpg.game import *
from rpg.area import Actor	

class ADnDActor(Actor)
def \_\_init\_\_(self, **params)
ADnD\_min\_disctans

def attack(actor):

	mod\_attack = self.str \% 10
	hit = randrange(1,20) + mod\_attack
	damage = randrange(1, weapon) + mod\_attack
	if (abc(self.x - actor.x) <= weapon\_min\_distance \&\& abc(self.y - actor.y) <= weapon\_min\_distance)
		if (hit >= obj.ac)
		actor.hp -= damage
		if actor.hp <= 0)
			actor.alive = false
			start\_script("death", self.death\_script, actor)\\
			stop\_script("death")

def death\_script(actor)
	actor.status = "death" % возможно правильнее self.cateory = "death"
	actor.add\_anim("death")
	actor.status = "corspe" % возможно правильнее self.cateory = "corspe"

new\_actor("Knight", ADnDActor, category: "enemy", ...)

\paragraph{Создание заклинаний с их действием}
Создание заклинаний с их действием. С магией можно сделать так: абстрактный класс Spell, где есть метод cast(actor1, actor2), то есть actor1 делает cast на actor2. он изначально пустой. А в new\_spell мы должны указать функцию как именно должен работать Spell (можно прямо как lambda):

модуль bggame:
from rpg.game import *
from rpg.area import Spell

new\_spell("Fireball", level:3, class: ["wizard", "priest"], lambda a1,a2 : a2.hp -= 30)

\paragraph{Создание зон, заполнение их персонажами/объектами}
Мир также состоит из зон (Area). Каждая зона включает в себя графику, персонажи и предметы и сценарии взаимодействия. Исключение составляет команда PC, которая может перемещаться из зоны в зону (это мы программируем у клиента). Как программируются зоны. Если нужны локальные переменные (состояние локальных событий), то тогда нужно создавать класс своей зоны как наследник от Area. Или же просто использовать класс Area. Добавляем зону в игру new\_area(name, area). Переключаем зону - set\_area(name). Так же требуется задать область движения, её проще сделать как совокупность прямоугольников, за которые персонажи не могут выйти. Эти прямоугольники должны касаться друг друга, но не пересекаться. Тогда алгоритм проверки выхода несложный: выход за пределы области только тогда, когда прямоугольник персонажа пересек сторону (одну или две) одного из прямоугольников области, эта сторона не является касательной.

from rpg.game import *
from rpg.area import Area
forest = Area()
forest.add\_sprite(0, 0, 0, Sprite("back.png"))
sword = Sword(normal: Sprite("sword.jpg"))
forest.add\_object(10, 10, sword)
forest.add\_sprite(0, 0, 0, Sprite("brown.png"))
door = Door(normal: Sprite("door.png"))
forest.add\_object(50, 50, door)
man = ManNPC(left: Animation("left.png"), right: Animation("right.png"))
player = PlayerPC(left: Animation("left.png"), right: Animation("right.png"))
forest.add\_object(100, 100, man)
forest.add\_object(150, 132, player)

def man\_dialog():
...

man.set\_click\_script(man\_dialog)
new\_area("Forest", forest)

\paragraph{Пример сценариев: переход между зонами}
Глобальные сценарии находятся в классе игры (BGGame), мы подключаем их как :
Area.set\_enter\_script(script)
На объект мы добавляем сценарий для взаимодействия как: obj.set\_click\_script(script)
Как происходит переход команды между зонами.
В зоне определяем объект дверь, по клику мыши она может открываться и закрываться (меняется состояние объекта). Назначаем сценарий set\_walk\_script(script), который срабатывает когда кто-то из команды пересекает объект. В этом сценарии мы меняем зону на нужную (set\_area), и устанавливаем команду в нужную позицию (set\_team). В другой зоне делается аналогично, только переход и позиция будут другими.
Сценарий перехода - в модуле зоны, и там не нужны проверки координат, потому что сработает движок на пересечение объекта. Нужен какой-то объект (нора, дверь ...) на который назначается walk\_script
А в самом сценарии просто меняем зону и переставляем команду put\_team(50, 50) (команда в движке)

модуль bggame:
from rpg.game import *

def walk\_script():
	if (act.x = door.x \&\& act.y = door.y)
		set\_area("Bandits lair")
		put\_team(50, 50)

import forest

set\_area("Forest")
set\_team(teampc, forest, 100, 100)


set\_walk\_script(walk\_script)

import lair

%set\_area("Bandits lair")
%put\_team(teampc, lair, 50, 50)

\paragraph{Как будет идти бой}
Боевая система - я предполагаю, что боевая система будет пошаговая. То есть Существует боевая ситуация, которая активируется триггером. В мирном состоянии пользователь управляя персонажем PC может передвигаться свободно, на любые расстояния преодолевая препятствия. Другие NPC тоже будут передвигаться спокойно передвигаться согласно их скриптам. Боевая ситуация активируется только в случае, если PC будет входить в зону видимости NPC category: enemy. Я добавлю NPC "прямоугольник" размером 60 на 60 пикселей, от точки NPC на карте, который проверяет есть ли в площади этого "прямоугольника" координаты игрока. В случае когда координаты игрока попадают в этот прямоугольник, то начинается боевая ситуация. Либо сделать по-другому, при попадании в новую зону команды PC, если в этой зоне есть NPC category: enemy, то начинается скрипт set\_battle\_script(script)"боевая ситуация" начинается сразу же. Боевая ситуация будет представлять из себя следующее:
Очередь: все персонажи будут совершать все действия по очереди. Будет список в котором отсортированны по значению параметра agility все персонажи, которые участвуют в боевой ситуации в конкретной зоне. Будет у всех участников флаг, который активен, только когда имя того персонажа, находится вверху списка. Список будет обновляться после совершения любого действия. После совершения действия имя персонажа в списке переносится в конец списка, у персонажа отключается флаг хода, а в начало списка переносится следующий элемент в списке, при смерти персонажа, его имя удаляется из списка.
Действия NPC: Я предполагаю, что поведение NPC в боевой ситуации, определяется скриптами написанными пользователем специально для боя. Т.е. пользователь пишет свой battle\_script для каждого экземпляра класса ADndActor. Скрипт будет вызывать методы передвижения или атаки в зависимости от того как должен вести себя каждый NPC category: enemy. Т.е. у условного скелета скрип будет вызывать метод skeleton.attack(actor) по возможности, если его нецелесообразно использовать(расстояние не позволяет совершать метод attack), то вызывать skeleton.move(x,y). У условного ящера скрипт будет будет вызывать метод lizardman.move(x,y) чтобы увеличить расстояние, а когда оно будет больше 100 единиц по модулю, то только после этого будет вызываться метод lizardman.attack(actor), потому что ящер стреляет из лука, а это значит расстояние для атаки у него больше, чем у того-же скелета. Таким образом все действия NPC определяются заранее написанными скриптами. Но я пока не представляю, как задать эти скрипты В модуле bggame наверное или в каждом экземпляре класса ADndActor. Я не уверен.
Окончание боевой ситуации: бой заканчивается, когда в списке очереди, остаётся одно имя или вообще никаких, скрип перестаёт действовать (stop\_thread).

Тут надо делать разные сценарии. Собственно начало боя - это тоже сценарий (зашел в комнату, сработал walk\_script на что-то (или enter\_script - сценарий, который запускается при входе команды в зону). Условно этот сценарий называется battle\_script. Там мы прописываем правила боя (может достаточно только установить глобальный режим боя и проверять условие окончания боя). Пошаговый, значит в определенный момент мы выключаем управление игрока (обработку мыши, клавиш) - control\_off(), а затем опять включаем control\_on(). Когда наш ход, мы должны считать очки движения/действий. Это может делать сценарий по событию движения персонажа (move\_script - тоже может быть один на всех: и своих и врагов).
click\_script - сценарий по нажатию на врагов, делает атаку, если позволяет расстояние. Причем, это делается только если режим боя (то есть установлена глобальная переменная). Когда очки закончились (или нажата кнопка конец хода), то мы запускаем enemy\_script, который выключает управление игрока и по очереди запускает сценарии ai у врагов. Все сценарии работают параллельно (хотя реально работает только один сценарий в определенный момент времени), и в Питоне они должны передавать управление друг другу, это команда движка yield(есть примеры в Интернете как это сделать).

модуль bggame:
from rpg.game import *
actors\_list =()
def battle\_script(**params)
	actors\_list = (params)
	action\_points = 2
	While (actors\_list.len > 1)
		if (actor\_1.agi >= actor\_2.agi)
			yield actor\_1.click\_script()
		if (actor\_2.agi > actor\_1.agi)
		yield actor\_2.enemy\_script()
	stop\_script()
def click\_script(self, actor)
	 self.attack(actor)
	 self.move\_script()
	 self.control\_off()
	 if (actor.status = "corspe")
	 	actors\_list.remove(actor)
def enemy\_script(self)
	if (self.attack(actor) \&\& actor.distance <= self\_weapon\_min\_distance)
		yield self.attack(actor)
	if (self.move\_script() \&\& actor.distance > self\_weapon\_min\_distance)
		yield self.move\_script()
	actor.control\_on()
	if (actor.status = "corspe")
		actors\_list.remove(actor)
def move\_script(self)
	self.move(point)

lair.battle\_script(player, bandit)

\paragraph{Сценарии с диалогами}
NPC category: friend будут при клике на них вызывать сценарий, который будет вызвать окно в котором будет поле, содержащее текст прописанный этим скриптом. 

def man\_say\_text():
...

man.set\_click\_script( man\_say\_text)

\paragraph{Соединение движка и окон tkinter}
Модуль graphics содержит в себе библиотеку tkinter . Класс Graphics внутри модуля является наследником tk.Canvas. Этот класс взаимодействует с окном root = tk.TK() в программном модуле пользователя. Модуль sprite тоже взаимодействует с tkinter. Изображение для спрайта берётся с помощью метода tk.PhotoImage(file=name)

модуль sprite

import tkinter as tk
class Sprite:
"""Класс спрайта для работы с изображениями на Canvas."""
def \_\_init\_\_(self, image):
self.image = tk.PhotoImage(file=image)
self.tag = None
self.x = 0
self.y = 0
self.z = 0

модуль graphics

import tkinter as tk
import time
class Graphics(tk.Canvas):
"""Класс Canvas с дополнительными методами для работы со спрайтами."""
def \_\_init\_\_(self, master, **kwargs):
super().\_\_init\_\_(master, **kwargs)
self.sprites = []  \# список спрайтов
self.mouse = None

def add\_sprite(self, sprite, x, y, z, **kwargs):
"""Добавляет спрайт на Canvas.
param sprite - экземпляр спрайта, x y z - коодринаты."""
tag = self.create\_image(x, y, image=sprite.image, anchor='center', **kwargs)
sprite.set\_tag(tag)
sprite.set\_z(z)  \# устанавливаем z-координату спрайта
sprite.x = x
sprite.y = y
self.sprites.append(sprite)
self.sprites.sort(key=lambda sprite: sprite.z) \# сортировка спрайтов по z-координате

модуль baldursgame '''пользовательский модуль'''

from rpg.sprite import *
from rpg.game import *
from rpg.area import *
from rpg.actor import *
import datetime
import threading

def timer():
first\_game.update()
root.after(1000, timer)

root = tk.Tk()
root.geometry('1500x1500')

exit\_button = tk.Button(root, text="Exit", fg="red", command=root.destroy)
exit\_button.pack()

\# Создание экземпляра класса graphics, который будет взаимодействовать с окном
canvas = Graphics(root, width=1500, height=1500)

\# Загрузка изображения
im1\_1 = Sprite('images/fon1.png')
im1\_2 = Sprite('images/fon2.png')
im2\_1 = Sprite('images/person1.png')
im2\_2 = Sprite('images/person2.png')

\subsection{Модули и классы}
\subsection{Game}
\subsubsection{Описание модуля}
\paragraph{Конструктор и поля модуля}
def \_\_init\_\_(self, **params) 
\begin{itemize}
	\item self.rpg\_dict\_of\_area = {} 
	\item Описание параметра: параметр - словарь, хранящий в себе множество экземпляров класса Area, {number - ключ : name Area - значение}.
	\item self.team\_of\_pc[] = name\_pc 
	\item Описание параметра: параметр - список, хранящий в себе имена экземпляров класса Actor с параметром category = "pc".
\end{itemize}
\subsubsection{Методы}
\paragraph{New\_item}
def new\_item(self, name, **params)
Описание метода: метод отвечающий за создание класса, потомка от Item и создание поля из параметров, и установление их в начальные значения.
\paragraph{New\_spell}
def new\_spell(self, name, **params, self. name, level, type, damage, hp)
Описание метода: метод отвечающий за создание класса, потомка от Spell и создание поля из параметров, и установление их в начальные значения.
\paragraph{New\_actor}
def new\_actor(self, name, **params)
Описание метода: метод отвечающий за создание класса, потомка от Actor и создание поля из параметров, и установление их в начальные значения.
\paragraph{New\_area}
def new\_area(name, area)
Описание метода: метод отвечающий за создание класса, потомка от Area и создание поля из параметров, и установление их в начальные значения.
\paragraph{Set\_area}
def set\_area(name)
Описание метода: метод отвечающий за размещение экземпляра класса Area в поле rpg\_dict\_of\_area класса game.
\paragraph{Add\_pc\_to\_team}
def add\_pc\_to\_team(self, pc)
Описание метода: метод отвечающий за добавление имени экземпляра класса Actor с параметром category = "pc" в список team\_of\_pc, хранящий имена всех игровых персонажей.
\paragraph{Remove\_pc\_from\_team}
def remove\_pc\_from\_team(self, pc)
Описание метода: метод отвечающий за удаление имени экземпляра класса Actor с параметром category = "pc" в список team\_of\_pc, хранящий имена всех игровых персонажей.
\paragraph{Start\_script}
def start\_script(script)
Описание метода: метод отвечающий за активацию скрипта.
\paragraph{Stop\_thread}
def stop\_thread(script)
Описание метода: метод отвечающий за прекращение действий скрипта.

\subsection{Area}
\subsubsection{Описание модуля}
\paragraph{Конструктор и поля модуля}
def \_\_init\_\_(self, **params)
\begin{itemize}
	\item self.area\_zone = params
	\item Описание параметра: параметр определяющий особенности конкретной зоны (то есть Лес, скорость всех персонажей, понижена вдвое. Река передвижение по зоне невозможно и т.д.) %тут не уверен
	\item self.area\_list\_objects = params 
	\item Описание параметра: параметр - список, хранящий в себе множество экземпляров классов Item, Actor.
\end{itemize}
\subsubsection{Методы}
\paragraph{Add\_sprite}
def add\_sprite (x, y, sprite)
Описание метода: метод отвечающий за вызов метода add\_sprite у класса Graphics.
\paragraph{Add\_obj}
def add\_obj(self, name, obj, **params)
Описание метода: метод отвечающий за добавление экземпляров классов Item, Actor, в поле area\_list\_objects экземпляра класса Area.
\paragraph{Check\_obj\_sprite}
def check\_obj\_sprite(x, y, z, sprite)
Описание метода: метод отвечающий за проверку пересекаются ли координаты Sprite`ов различных объектов в экземпляре класса Area.
\paragraph{Set\_team}
def set\_team(x, y)
Описание метода: метод отвечающий за установку команды игровых персонажей в конкретной зоне

\subsection{Sprite}
\subsubsection{Описание модуля}
\paragraph{Конструктор и поля модуля}
def \_\_init\_\_(self, image)
\begin{itemize}
	\item self.spr\_image = image
	\item Описание параметра: параметр хранит изображение конкретного экземпляра класса Sprite.
	\item self.spr\_x = x
	\item Описание параметра: параметр хранит числовое значение обозначающее расположение конкретного экземпляра класса Sprite.
	\item self.spr\_y = y
	\item Описание параметра: параметр хранит числовое значение обозначающее расположение конкретного экземпляра класса Sprite.
	\item self.spr\_z = z
	\item Описание параметра: параметр хранит числовое значение обозначающее расположение конкретного экземпляра класса Sprite.
\end{itemize}

\subsection{Graphics}
\subsubsection{Описание модуля}
\paragraph{Конструктор и поля модуля}
def \_\_init\_\_(self)
\begin{itemize}
	\item self.anim = {}
	\item Описание параметра: список анимаций
\end{itemize}
\subsubsection{Методы}
\paragraph{Change\_frame}
def change\_frame(self, id, img)
Описание метода: Смена кадра анимации.
\paragraph{Add\_anim}
def add\_anim(self, a, b)
Описание метода: добавить анимацию
\paragraph{OnTimer}
def onTimer(self)
Описание метода: Цикл анимаций
\paragraph{Draw\_all}
def draw\_all(self, sprite)
Описание метода: отрисовать все спрайты
\paragraph{Add\_sprite}
def add\_sprite(self, sprite)
Описание метода: метод отвечающий за отображение экземпляра класса Sprite
\paragraph{Update}
def update(self)
Описание метода: метод проверяющий координаты всех объектов, состояния объектов, всех кадров анимаций, а затем вызывает метод draw\_all.

\subsection{Animation}
\subsubsection{Описание модуля}
\paragraph{Конструктор и поля модуля}
def \_\_init\_\_(self, name, file\_name, n, time)
\begin{itemize}
	\item self.frame = 0
	\item Описание параметра: """индекс кадра"""
	\item self.time = time
	\item Описание параметра: """скорость анимации"""
	\item self.name = name
	\item Описание параметра: """название анимации"""
	\item self.anim = []
	\item Описание параметра: """список кадров"""
	\item self.n = n
	\item Описание параметра: """колличество кадров в анимации"""
	\item self.file\_name = file\_name
	\item Описание параметра: """имя файла"""
\end{itemize}
\subsubsection{Методы}
\paragraph{onTimerAnimation}
def onTimerAnimation(self)
Описание метода: Счетчик кадров анимации.
\paragraph{Crop}
def crop(self)
Описание метода: Разбиение на кадры
\paragraph{Get\_frame}
def get\_frame(self)
Описание метода: Возвращает текущий кадр
\paragraph{Draw\_all}
def draw\_all(self, sprite)
Описание метода: отрисовать все спрайты

\subsection{Object}
\subsubsection{Описание модуля}
\paragraph{Конструктор и поля модуля}
def \_\_init\_\_(self, name, hp, ac, speed, bool(alive), bool(angry), damage, category, x, y, z)
\begin{itemize}
	\item self.obj\_name = name 
	\item Описание параметра: параметр хранит название конкретного экземпляра класса Object.
	\item self.obj\_hp = hp 
	\item Описание параметра: параметр хранит числовое значение обозначающее колличество единиц жизни у конкретного экземпляра класса Object.
	\item self.obj\_ac = ac
	\item Описание параметра: параметр хранит числовое значение обозначающее класс доспеха у конкретного экземпляра класса Object.
	\item self.obj\_speed = speed 
	\item Описание параметра: параметр хранит числовое значение обозначающее колличество единиц передвижения у конкретного экземпляра класса Object.
	\item self.obj\_alive = alive 
	\item Описание параметра: параметр хранит логическое значение обозначающее статус: жив или мёртв(возможно ли с ним взаимодействие) конкретный экземпляр класса Object.
	\item self.obj\_angry = angry 
	\item Описание параметра: параметр хранит логическое значение обозначающее агрессивно ли настроен конкретный экземпляр класса Object, т.е. может ли он вызывать метод def attack().
	\item self.obj\_damage = damage
	\item Описание параметра: параметр хранит числовое значение обозначающее колличество единиц урона, у конкретного экземпляра класса Object, на которое может быть уменьшено колличество единиц жизни(параметр obj\_hp) у другого экземпляра класса Object.
	\item self.obj\_category = category 
	\item Описание параметра: параметр хранит текстовое значение обозначающее принадлежность его к определённому наследуемому классу - т.е. у экземпляра класса PlayerCharacter category будет иметь значение "pc", у враждебно настроенного NPC(экземпляр класса Actor) будет иметь значение "enemy", у не враждебно настроенного NPC(экземпляр класса Actor) будет иметь значение "friend".
	\item self.obj\_pos\_x = x 
	\item Описание параметра: параметр хранит числовое значение обозначающее расположение на экране(или зоны - экземпляра класса Area) по координате x у конкретного экземпляра класса Object.
	\item self.obj\_pos\_y = y  
	\item Описание параметра: параметр хранит числовое значение обозначающее расположение на экране(или зоны - экземпляра класса Area) по координате y у конкретного экземпляра класса Object.
	\item self.obj\_pos\_z = z 
	\item Описание параметра: параметр хранит числовое значение обозначающее расположение на экране(или зоны - экземпляра класса Area) по координате z у конкретного экземпляра класса Object.
\end{itemize}
\subsubsection{Методы}
\paragraph{Move}
def move(self, x, y, z, speed):
Описание метода: метод отвечающий за изменение полей obj\_pos\_x, obj\_pos\_y obj\_pos\_z экземпляра класса Object.
\paragraph{Attack}
 def attack(obj):
Описание метода: метод отвечающий за изменение поля obj\_hp экземпляра класса Object.
\paragraph{Die}
def die(self, alive, category)
Описание метода: метод отвечающий за изменение полей obj\_category, obj\_alive экземпляра класса Object.
\paragraph{Set\_click\_script}
def set\_click\_script(script):
Описание метода: метод отвечающий за действие скрипта у конкретного объекта.

\subsection{Actor(Object)}
\subsubsection{Описание модуля}
\paragraph{Конструктор и поля модуля}
def \_\_init\_\_(self, name, **params)
\begin{itemize}
	\item self.act\_name = name 
	\item Описание параметра: параметр хранит название конкретного экземпляра класса Actor.
	\item self.act\_loot = loot 
	\item Описание параметра: параметр - список, который хранит в себе некоторое количество экземпляров класса Item.
	\item self.act\_text = text 
	\item Описание параметра: параметр хранит текстовое значение, которое будет выведено на экран методом readtext класса Actor.
	\item self.act\_class = class 
	\item Описание параметра: параметр хранит текстовое значение, обозначающее принадлежность к определённому классу игрового персонажа: "warrior" "wizard" "cleric".
	\item self.act\_level = level 
	\item Описание параметра: параметр хранит числовое значение обозначающее уровень у конкретного экземпляра класса Actor.
	\item self.act\_race = race 
	\item Описание параметра: параметр хранит текстовое значение, обозначающее принадлежность к определённой расе игрового персонажа: "human" "elf" "dwarf".
	\item self.act\_str = str 
	\item Описание параметра: параметр хранит числовое значение обозначающее колличество единиц параметра "сила" игрового персонажа у конкретного экземпляра класса Actor.
	\item self.act\_agi = agi 
	\item Описание параметра: параметр хранит числовое значение обозначающее колличество единиц параметра "ловкость" игрового персонажа у конкретного экземпляра класса Actor.
	\item self.act\_con = con 
	\item Описание параметра: параметр хранит числовое значение обозначающее колличество единиц параметра "телосложение" игрового персонажа у конкретного экземпляра класса Actor.
	\item self.act\_int = int 
	\item Описание параметра: параметр хранит числовое значение обозначающее колличество единиц параметра "интеллект" игрового персонажа у конкретного экземпляра класса Actor.
	\item self.act\_wiz = wiz 
	\item Описание параметра: параметр хранит числовое значение обозначающее колличество единиц параметра "мудрость" игрового персонажа у конкретного экземпляра класса Actor.
	\item self.act\_chr = chr
	\item Описание параметра: параметр хранит числовое значение обозначающее колличество единиц параметра "харизма" игрового персонажа у конкретного экземпляра класса Actor.
	\item self.act\_inventory = inventory
	\item Описание параметра: параметр - список, хранящий в себе множество экземпляров классов Item.
	\item self.act\_list\_spells = spells
	\item Описание параметра: параметр - список, хранящий в себе множество экземпляров классов Spell.
	\item self.act\_status\_cadr
	\item Описание параметра: параметр - хранит в себе текущий кадр анимации.
\end{itemize}
\subsubsection{Методы}
\paragraph{Readtext}
def readtext(self, text)
Описание метода: метод отвечающий за вывод содержания поля act\_text экземпляра класса Actor на экран.
\paragraph{Open\_inventory}
def open\_inventory(self, inventory)
Описание метода:  метод отвечающий за вывод содержимого поля act\_inventory на экран.
\paragraph{Open\_list\_spells}
def open\_list\_spells(self, spells):
Описание метода: метод отвечающий за вывод содержимого поля act\_list\_spells на экран.
\paragraph{Target\_use\_spell}
def target\_use\_spell(self, obj =Spell(), tar = Actor()):
Описание метода: метод отвечающий за вызов метода cast\_spell экземпляра класса Spell.
\paragraph{Target\_use\_item}
def target\_use\_item(self, obj =Item(), tar = Actor()):
Описание метода: метод отвечающий за вызов метода use\_item экземпляра класса Item.	

\subsection{Spell}
\subsubsection{Описание модуля}
\paragraph{Конструктор и поля модуля}
def \_\_init\_\_(self, name, level, type, damage)
\begin{itemize}
	\item self.spell\_name = name
	\item Описание параметра: параметр хранит название конкретного экземпляра класса Spell.
	\item self.spell\_level = level
	\item Описание параметра: параметр хранит числовое значение обозначающее уровень у конкретного экземпляра класса Spell.
	\item self.spell\_type = type
	\item Описание параметра: параметр хранит текстовое значение, обозначающее принадлежность к определённому типу заклинания (урон, лечение, перемещение) у конкретного экземпляра класса Spell.
	\item self.spell\_damage = damage
	\item Описание параметра: параметр хранит числовое значение обозначающее колличество единиц урона, у конкретного экземпляра класса Spell, на которое может быть уменьшено колличество единиц жизни(параметр obj\_hp) у другого экземпляра класса Object.

\end{itemize}
\subsubsection{Методы}
\paragraph{Cast\_spell}
def cast\_spell(self. actor1, actor2)
Описание метода: метод отвечающий за изменение поля obj\_hp экземпляра класса Object на число равное значению поля spell\_damage экземпляра класса Spell.
\paragraph{Learn\_spell}
def learn\_spell(self, name, level, list)
Описание метода: метод отвечающий за добавление в поле act\_list\_spells экземпляра класса Actor нового элемента.
\paragraph{Forget\_spell}
def def forget\_spell(self, name, level, list)
Описание метода: метод отвечающий за удаление из поля act\_list\_spells экземпляра класса Actor первого элемента.

\subsection{Item}
\subsubsection{Описание модуля}
\paragraph{Конструктор и поля модуля}
def \_\_init\_\_(self, name, category, type, ability)
\begin{itemize}
	\item self.it.category = category 
	\item Описание параметра: параметр хранит текстовое значение, обозначающее принадлежность к определённой категории предмета (оружие, доспех, магический предмет, прочее) у конкретного экземпляра класса Item.
	\item self.it.type = type 
	\item Описание параметра: параметр хранит текстовое значение, обозначающее принадлежность к определённому типу предмета, которое он может занимать в инвентаре (голова, одна рука, две руки, доспех, ноги, обувь, прочее) у конкретного экземпляра класса Item.
	\item self.it.ability = ability % сопособности предмета(доспех увеличивает класс доспеха, свиток новое заклинание и т.д.)
	\item Описание параметра: параметр хранит текстовое значение, обозначающее особенность (доспех, изменяет значение параметра obj\_ac у конкретного экземпляра класса Object, оружие изменяет значение параметра obj\_damage у конкретного экземпляра класса Object, магический предмет добавляет новый экземпляр класса Spell, в список act\_list\_spells конкретного экземпляра класса Actor, прочее, не изменяет параметров, но содержит текст, который будет выводится на экран, при взаимодействии пользователя с предметом) у конкретного экземпляра класса Item.
	\item self.it\_status\_cadr
	\item Описание параметра: параметр - хранит в себе текущий кадр анимации.
\end{itemize}
\subsubsection{Методы}
\paragraph{Use\_item}
def use\_item(self, ability, obj)
Описание метода: метод отвечающий за изменение полей obj\_hp, obj\_ac, obj\_speed экземпляра класса Object или полей act\_str, act\_agi экземпляра класса Actor на число равное значению поля it.ability экземпляра класса Item.
\paragraph{Equip\_item}
def equip\_item(actor, name, inventory)
Описание метода: метод отвечающий за добавление в список act\_inventory экземпляра класса Actor элемента с названием экземпляра класса Item.

