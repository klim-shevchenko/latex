\section{Технический проект}
\subsection{Общая характеристика организации решения задачи}

Необходимо спроектировать и разработать приложение, который должен способствовать популяризации ролевых игр.

Приложение представляет собой набор взаимосвязанных различных окон, которые сгруппированы по разделам, содержащие текстовую, графическую информацию. Приложение располагается на компьютере.

\subsection{Обоснование выбора технологии проектирования}

На сегодняшний день информационный рынок, поставляющий программные решения в выбранной сфере, предлагает множество продуктов, позволяющих достигнуть поставленной цели – разработки приложения.

\subsubsection{Описание используемых технологий и языков программирования}

В процессе разработки приложения используются программные средства и языки программирования. Каждое программное средство и каждый язык программирования применяется для круга задач, при решении которых они необходимы.

\subsubsection{Язык программирования Python}

Python –  высокоуровневый язык программирования общего назначения с динамической строгой типизацией и автоматическим управлением памятью, ориентированный на повышение производительности разработчика, читаемости кода и его качества, а также на обеспечение переносимости написанных на нём программ. Язык является полностью объектно-ориентированным в том плане, что всё является объектами. Необычной особенностью языка является выделение блоков кода отступами. Синтаксис ядра языка минималистичен, за счёт чего на практике редко возникает необходимость обращаться к документации. Сам же язык известен как интерпретируемый и используется в том числе для написания скриптов. Недостатками языка являются зачастую более низкая скорость работы и более высокое потребление памяти написанных на нём программ по сравнению с аналогичным кодом, написанным на компилируемых языках, таких как C или C++.

\subsubsection{Язык программирования Python}

\paragraph{Достоинства языка Python}
\begin{itemize}
	\item Простота и читаемость кода: Python использует простой и чистый синтаксис, что делает код легким для понимания и обслуживания.
	\item Многофункциональность: Python подходит для создания различных типов приложений, включая веб-приложения, настольные приложения, научные вычисления, обработку данных и многое другое
	\item Большой выбор библиотек: Python имеет огромное сообщество разработчиков, что приводит к большому количеству библиотек и модулей для различных задач. Например, для машинного обучения есть библиотека TensorFlow, для веб-разработки - Django, для анализа данных - Pandas и многое другое.
	\item Кроссплатформенность: Python работает на различных операционных системах, таких как Windows, macOS, Linux и другие.
	\item Быстрая разработка: Python позволяет быстро создавать прототипы и тестировать идеи благодаря своей простоте и мощности.
\end{itemize}

\paragraph{Недостатки языка Python}

\begin{itemize}
	\item Низкая производительность: Python может быть медленнее других языков программирования, таких как C++ или Java, особенно при выполнении вычислительно сложных операций.
	\item Глобальная блокировка интерпретатора: из-за глобальной блокировки GIL (Global Interpreter Lock) в Python, многопоточные приложения могут испытывать проблемы с параллельным выполнением кода.
	\item Не самый подходящий для мобильной разработки: Python не является первым выбором для мобильной разработки из-за ограниченной поддержки на мобильных платформах.
	\item Не все библиотеки могут быть на Python: Так как Python находится в постоянном развитии, не все библиотеки могут быть доступны на этом языке.
	\item Меньшая поддержка для некоторых областей разработки, таких как игровая разработка или высокопроизводительные вычисления.
\end{itemize}

\subsubsection{Использование библиотеки Tkinter и реализация таймеров на Python}
	
\paragraph{Введение}
Библиотека Tkinter - это стандартная библиотека Python для создания графического пользовательского интерфейса (GUI). Она обладает широкими возможностями для создания разнообразных приложений с использованием различных виджетов, таких как кнопки, поля ввода, метки и многое другое.
	
\paragraph{Возможности Tkinter}
Вот некоторые из основных возможностей, предоставляемых библиотекой Tkinter:
	
\begin{itemize}
	\item Создание различных виджетов: кнопки, метки, поля ввода, списки и многое другое.
	\item Управление компоновкой виджетов с использованием менеджеров компоновки (например, grid, pack, place).
	\item Обработка событий, таких как щелчок мыши, нажатие клавиш и другие.
	\item Возможность создания различных диалоговых окон, таких как окна предупреждений, информационные окна и окна запроса.
	\item Поддержка многопоточности для обновления интерфейса из различных потоков выполнения.
\end{itemize}
	
\paragraph{Реализация таймеров на Python}
Для реализации таймеров на Python можно использовать модуль \texttt{time} или \texttt{threading}. Вот пример использования модуля \texttt{time} для создания простого таймера:
	
	import time
	
	def countdown(t):
	while t > 0:
	mins, secs = divmod(t, 60)
	timeformat = '{:02d}:{:02d}'.format(mins, secs)
	print(timeformat, end='\r')
	time.sleep(1)
	t -= 1
	print('Таймер завершен!')
	
	\# Установка времени для таймера (в секундах)
	t = 10
	countdown(t)
	
Этот код создает простой обратный отсчет таймера с использованием функции \texttt{countdown}. Он выводит оставшееся время в формате ММ:СС и уменьшает его на 1 каждую секунду, используя функцию \texttt{time.sleep(1)}. Когда время истекает, выводится сообщение о завершении таймера.
	
\paragraph{Заключение}
Библиотека Tkinter предоставляет мощные инструменты для создания графических пользовательских интерфейсов на языке Python. Реализация таймеров на Python может быть достигнута с помощью модулей \texttt{time} или \texttt{threading}, в зависимости от конкретных требований приложения.

\subsection{Описание платформы для создания RPG игр}
Клиент создает модуль содержащий методы модуля RPGGame, например BaldursGateGame. В этом модуле мы создаем мир игры, с помощью new\_actor, new\_item, new\_spell. Мы можем вызывать их много раз с разными параметрами, или загрузить параметры для этих функций из файла. После чего у нас есть персонажи и предметы. Мир также состоит из зон (Area). Каждая зона включает в себя графику, персонажи и предметы и сценарии взаимодействия. Исключение составляет команда PC, которая может перемещаться из зоны в зону (это мы программируем у клиента). Команду мы тоже определяем стартовую и впоследствии можем менять (add\_actor\_to\_team, remove\_actor\_from\_team). Каждому персонажу и предмету может соответствовать пользовательский сценарий (он активируется при нажатии мышкой на объект). Сценарий может включать диалог, взятие предмета, добавление персонажа в команду, квест и т.д.
Зона тоже может содержать сценарий, который запускается когда команда попадает в зону.
Клиентский класс (BGGame) также содержит глобальные переменные, определяющие ситуации в игре (например квесты). Локальные переменные могут быть в зоне.

Как программируются зоны. Если нужны локальные переменные (состояние локальных событий), то тогда нужно создавать класс своей зоны как наследник от Area. Или же просто использовать класс Area. Добавляем зону в игру new\_area(name, area). Переключаем зону - set\_area(name). Глобальные сценарии находятся в классе игры (BGGame), мы подключаем их как :
Area.set\_enter\_script(script)
В зону мы добавляем персонажей и предметы как add\_object(x,y, obj) - z не нужно, так как слой можно определить по y координате.
На объект мы добавляем сценарий для взаимодействия как: obj.set\_click\_script(script)
Как происходит переход команды между зонами.
В зоне определяем объект дверь, по клику мыши она может открываться и закрываться (меняется состояние объекта). Назначаем сценарий set\_walk\_script(script), который срабатывает когда кто-то из команды пересекает объект. В этом сценарии мы меняем зону на нужную (set\_area), и устанавливаем команду в нужную позицию (set\_team). В другой зоне делается аналогично, только переход и позиция будут другими.
Сценарии - это потоки которые запускаются параллельно (метод RPGGame.start\_script(script)). Сценарий может быть остановлен (stop\_thread).
Таким образом, мир будет интерактивным.
Как связано окно и графика с игрой. В окне мы делаем таймер, который вызывает метод update нашей игры (BGGame). Этот метод выполняет все действия объектов в игре за 1 кадр времени.
Также в таймере вызываем Graphics.update(), который обновляет графику игры.
Все объекты (Actor, Item) должны иметь состояния (как минимум одно). Каждое состояние связано с спрайтом (или анимацией). То есть переключение состояния меняет графику объекта.

А вообще сценарии и глобальные переменные могут быть без классов, а просто в модулях, так проще, чтобы к ним был доступ из всех комнат. Тогда и функции движка должны быть доступны везде (то есть во всех сценариях). Например делаем модуль лес (forest):
from rpg.game import *
from rpg.area import Area
forest = Area()
forest.add\_sprite(0, 0, 0, Sprite("back.jpg"))
sword = Sword(normal: Sprite("sword.jpg"))
forest.add\_object(10, 10, sword)
forest.add\_sprite(0, 0, 0, Sprite("brown.jpg"))
door = Door(normal: Sprite("door.jpg"))
forest.add\_object(50, 50, door)
man = ManNPC(left: Animation("left.jpg"), right: Animation("right.jpg"))
player = PlayerPC(left: Animation("left.jpg"), right: Animation("right.jpg"))
forest.add\_object(100, 100, man)
forest.add\_object(150, 132, player)

def man\_dialog():
...

man.set\_click\_script(man\_dialog)
new\_area("Forest", forest)

lair = Area()
lair.add\_sprite(0, 0, 0, Sprite("green.jpg"))
knife = Knife(normal: Sprite("knife.jpg"))
lair.add\_object(60, 80, knife)
bandit = EnemyNPC(left: Animation("left.jpg"), right: Animation("right.jpg"))
player = PlayerPC(left: Animation("left.jpg"), right: Animation("right.jpg"))
lair.add\_object(100, 100, bandit)
lair.add\_object(50, 50, player)

new\_area("Bandits lair", lair)

модуль bggame:
from rpg.game import *
teampc =()
new\_item("Sword", category: "Weapon", attack: 10)
new\_actor("ManNPC",  ADnDActor, category: "NPC")
new\_actor("Bandit",  ADnDActor, category: "enemy")
new\_actor("PlayerPC" ,ADnDActor, category: "PC")
add\_actor\_to\_team(PlayerPC, teampc)

def walk\_script():
	if (act.x = door.x \&\& act.y = door.y)
		set\_area("Bandits lair")
		put\_team(50, 50)

import forest

set\_area("Forest")
set\_team(teampc, forest, 100, 100)


set\_walk\_script(walk\_script)

import lair


Еще надо определиться, как задать правила AD\&D.
Лучше так: сделать класс ADnDActor (это делает клиент, не движок), где мы перекрываем метод attack, и там программируем формулу расчета повреждения, уменьшаем hp и т.д.
То есть Actor.attack(actor), где actor - кого атакуют
Тогда надо в методе new\_actor указывать еще один параметр - базовый класс, от которого будет наследование.
Пример.
new\_actor("Knight", ADnDActor, category: "enemy", ...)
С магией можно сделать так:
абстрактный класс Spell, где есть метод cast(actor1, actor2), то есть actor1 делает cast на actor2. он изначально пустой. А в new\_spell мы должны указать функцию как именно должен работать Spell (можно прямо как lambda):
new\_spell("Fireball", level:3, class: ["wizard", "priest"], lambda a1,a2 : a2.hp -= 30)
проверку на класс (который требуется) можно изначально сделать в Spell


\subsubsection{Пример клиентского кода игры}
\paragraph{Cоздание классов персонажей/предметов}
Клиент создает модуль содержащий методы модуля RPGGame, например BaldursGateGame. В этом модуле клиент создаем мир игры, с помощью new\_actor, new\_item, new\_spell. 

модуль bggame:
from rpg.game import *
teampc =()
new\_item("Sword", category: "Weapon", attack: 10)
new\_actor("ManNPC", ADnDActor, category: "NPC")
new\_actor("Bandit",  ADnDActor, category: "enemy")
new\_actor("PlayerPC", ADnDActor, category: "PC")
new\_spell("Fireball", level:3, class: ["wizard", "priest"], lambda a1,a2 : a2.hp -= 30)
pc = PlayerPC()
add\_actor\_to\_team(pc)

\paragraph{Задание правил атаки}
Пользователь создаёт класс ADnDActor, наследник от класса Actor в своём модуле bggame, в нём он прописывает свои правила по которым происходит атака. То есть Actor.attack(actor), где actor - кого атакуют
Тогда надо в методе new\_actor указывать еще один параметр - базовый класс, от которого будет наследование.
Пример.

модуль bggame:
from rpg.game import *
from rpg.area import Actor	

class ADnDActor(Actor)
def \_\_init\_\_(self, **params)
ADnD\_min\_disctans

def attack(actor):

	mod\_attack = self.str \% 10
	hit = randrange(1,20) + mod\_attack
	damage = randrange(1, weapon) + mod\_attack
	if (abc(self.x - actor.x) <= weapon\_min\_distance \&\& abc(self.y - actor.y) <= weapon\_min\_distance)
		if (hit >= obj.ac)
		actor.hp -= damage
		if actor.hp <= 0)
			actor.alive = false
			start\_script("death", self.death\_script, actor)\\
			stop\_script("death")

def death\_script(actor)
	actor.status = "death" % возможно правильнее self.cateory = "death"
	actor.add\_anim("death")
	actor.status = "corspe" % возможно правильнее self.cateory = "corspe"

new\_actor("Knight", ADnDActor, category: "enemy", ...)

\paragraph{Создание заклинаний с их действием}
Создание заклинаний с их действием. С магией можно сделать так: абстрактный класс Spell, где есть метод cast(actor1, actor2), то есть actor1 делает cast на actor2. он изначально пустой. А в new\_spell мы должны указать функцию как именно должен работать Spell (можно прямо как lambda):

модуль bggame:
from rpg.game import *
from rpg.area import Spell

new\_spell("Fireball", level:3, class: ["wizard", "priest"], lambda a1,a2 : a2.hp -= 30)

\paragraph{Создание зон, заполнение их персонажами/объектами}
Мир также состоит из зон (Area). Каждая зона включает в себя графику, персонажи и предметы и сценарии взаимодействия. Исключение составляет команда PC, которая может перемещаться из зоны в зону (это мы программируем у клиента). Как программируются зоны. Если нужны локальные переменные (состояние локальных событий), то тогда нужно создавать класс своей зоны как наследник от Area. Или же просто использовать класс Area. Добавляем зону в игру new\_area(name, area). Переключаем зону - set\_area(name). Так же требуется задать область движения, её проще сделать как совокупность прямоугольников, за которые персонажи не могут выйти. Эти прямоугольники должны касаться друг друга, но не пересекаться. Тогда алгоритм проверки выхода несложный: выход за пределы области только тогда, когда прямоугольник персонажа пересек сторону (одну или две) одного из прямоугольников области, эта сторона не является касательной.

from rpg.game import *
from rpg.area import Area
forest = Area()
forest.add\_sprite(0, 0, 0, Sprite("back.png"))
sword = Sword(normal: Sprite("sword.jpg"))
forest.add\_object(10, 10, sword)
forest.add\_sprite(0, 0, 0, Sprite("brown.png"))
door = Door(normal: Sprite("door.png"))
forest.add\_object(50, 50, door)
man = ManNPC(left: Animation("left.png"), right: Animation("right.png"))
player = PlayerPC(left: Animation("left.png"), right: Animation("right.png"))
forest.add\_object(100, 100, man)
forest.add\_object(150, 132, player)

def man\_dialog():
...

man.set\_click\_script(man\_dialog)
new\_area("Forest", forest)

\paragraph{Пример сценариев: переход между зонами}
Глобальные сценарии находятся в классе игры (BGGame), мы подключаем их как :
Area.set\_enter\_script(script)
На объект мы добавляем сценарий для взаимодействия как: obj.set\_click\_script(script)
Как происходит переход команды между зонами.
В зоне определяем объект дверь, по клику мыши она может открываться и закрываться (меняется состояние объекта). Назначаем сценарий set\_walk\_script(script), который срабатывает когда кто-то из команды пересекает объект. В этом сценарии мы меняем зону на нужную (set\_area), и устанавливаем команду в нужную позицию (set\_team). В другой зоне делается аналогично, только переход и позиция будут другими.
Сценарий перехода - в модуле зоны, и там не нужны проверки координат, потому что сработает движок на пересечение объекта. Нужен какой-то объект (нора, дверь ...) на который назначается walk\_script
А в самом сценарии просто меняем зону и переставляем команду put\_team(50, 50) (команда в движке)

модуль bggame:
from rpg.game import *

def walk\_script():
	if (act.x = door.x \&\& act.y = door.y)
		set\_area("Bandits lair")
		put\_team(50, 50)

import forest

set\_area("Forest")
set\_team(teampc, forest, 100, 100)


set\_walk\_script(walk\_script)

import lair

%set\_area("Bandits lair")
%put\_team(teampc, lair, 50, 50)

\paragraph{Как будет идти бой}
Боевая система - я предполагаю, что боевая система будет пошаговая. То есть Существует боевая ситуация, которая активируется триггером. В мирном состоянии пользователь управляя персонажем PC может передвигаться свободно, на любые расстояния преодолевая препятствия. Другие NPC тоже будут передвигаться спокойно передвигаться согласно их скриптам. Боевая ситуация активируется только в случае, если PC будет входить в зону видимости NPC category: enemy. Я добавлю NPC "прямоугольник" размером 60 на 60 пикселей, от точки NPC на карте, который проверяет есть ли в площади этого "прямоугольника" координаты игрока. В случае когда координаты игрока попадают в этот прямоугольник, то начинается боевая ситуация. Либо сделать по-другому, при попадании в новую зону команды PC, если в этой зоне есть NPC category: enemy, то начинается скрипт set\_battle\_script(script)"боевая ситуация" начинается сразу же. Боевая ситуация будет представлять из себя следующее:
Очередь: все персонажи будут совершать все действия по очереди. Будет список в котором отсортированны по значению параметра agility все персонажи, которые участвуют в боевой ситуации в конкретной зоне. Будет у всех участников флаг, который активен, только когда имя того персонажа, находится вверху списка. Список будет обновляться после совершения любого действия. После совершения действия имя персонажа в списке переносится в конец списка, у персонажа отключается флаг хода, а в начало списка переносится следующий элемент в списке, при смерти персонажа, его имя удаляется из списка.
Действия NPC: Я предполагаю, что поведение NPC в боевой ситуации, определяется скриптами написанными пользователем специально для боя. Т.е. пользователь пишет свой battle\_script для каждого экземпляра класса ADndActor. Скрипт будет вызывать методы передвижения или атаки в зависимости от того как должен вести себя каждый NPC category: enemy. Т.е. у условного скелета скрип будет вызывать метод skeleton.attack(actor) по возможности, если его нецелесообразно использовать(расстояние не позволяет совершать метод attack), то вызывать skeleton.move(x,y). У условного ящера скрипт будет будет вызывать метод lizardman.move(x,y) чтобы увеличить расстояние, а когда оно будет больше 100 единиц по модулю, то только после этого будет вызываться метод lizardman.attack(actor), потому что ящер стреляет из лука, а это значит расстояние для атаки у него больше, чем у того-же скелета. Таким образом все действия NPC определяются заранее написанными скриптами. Но я пока не представляю, как задать эти скрипты В модуле bggame наверное или в каждом экземпляре класса ADndActor. Я не уверен.
Окончание боевой ситуации: бой заканчивается, когда в списке очереди, остаётся одно имя или вообще никаких, скрип перестаёт действовать (stop\_thread).

Тут надо делать разные сценарии. Собственно начало боя - это тоже сценарий (зашел в комнату, сработал walk\_script на что-то (или enter\_script - сценарий, который запускается при входе команды в зону). Условно этот сценарий называется battle\_script. Там мы прописываем правила боя (может достаточно только установить глобальный режим боя и проверять условие окончания боя). Пошаговый, значит в определенный момент мы выключаем управление игрока (обработку мыши, клавиш) - control\_off(), а затем опять включаем control\_on(). Когда наш ход, мы должны считать очки движения/действий. Это может делать сценарий по событию движения персонажа (move\_script - тоже может быть один на всех: и своих и врагов).
click\_script - сценарий по нажатию на врагов, делает атаку, если позволяет расстояние. Причем, это делается только если режим боя (то есть установлена глобальная переменная). Когда очки закончились (или нажата кнопка конец хода), то мы запускаем enemy\_script, который выключает управление игрока и по очереди запускает сценарии ai у врагов. Все сценарии работают параллельно (хотя реально работает только один сценарий в определенный момент времени), и в Питоне они должны передавать управление друг другу, это команда движка yield(есть примеры в Интернете как это сделать).

модуль bggame:
from rpg.game import *
actors\_list =()
def battle\_script(**params)
	actors\_list = (params)
	action\_points = 2
	While (actors\_list.len > 1)
		if (actor\_1.agi >= actor\_2.agi)
			yield actor\_1.click\_script()
		if (actor\_2.agi > actor\_1.agi)
		yield actor\_2.enemy\_script()
	stop\_script()
def click\_script(self, actor)
	 self.attack(actor)
	 self.move\_script()
	 self.control\_off()
	 if (actor.status = "corspe")
	 	actors\_list.remove(actor)
def enemy\_script(self)
	if (self.attack(actor) \&\& actor.distance <= self\_weapon\_min\_distance)
		yield self.attack(actor)
	if (self.move\_script() \&\& actor.distance > self\_weapon\_min\_distance)
		yield self.move\_script()
	actor.control\_on()
	if (actor.status = "corspe")
		actors\_list.remove(actor)
def move\_script(self)
	self.move(point)

lair.battle\_script(player, bandit)

\paragraph{Сценарии с диалогами}
NPC category: friend будут при клике на них вызывать сценарий, который будет вызвать окно в котором будет поле, содержащее текст прописанный этим скриптом. 

def man\_say\_text():
...

man.set\_click\_script( man\_say\_text)

\paragraph{Соединение движка и окон tkinter}
Модуль graphics содержит в себе библиотеку tkinter . Класс Graphics внутри модуля является наследником tk.Canvas. Этот класс взаимодействует с окном root = tk.TK() в программном модуле пользователя. Модуль sprite тоже взаимодействует с tkinter. Изображение для спрайта берётся с помощью метода tk.PhotoImage(file=name)

модуль sprite

import tkinter as tk
class Sprite:
"""Класс спрайта для работы с изображениями на Canvas."""
def \_\_init\_\_(self, image):
self.image = tk.PhotoImage(file=image)
self.tag = None
self.x = 0
self.y = 0
self.z = 0

модуль graphics

import tkinter as tk
import time
class Graphics(tk.Canvas):
"""Класс Canvas с дополнительными методами для работы со спрайтами."""
def \_\_init\_\_(self, master, **kwargs):
super().\_\_init\_\_(master, **kwargs)
self.sprites = []  \# список спрайтов
self.mouse = None

def add\_sprite(self, sprite, x, y, z, **kwargs):
"""Добавляет спрайт на Canvas.
param sprite - экземпляр спрайта, x y z - коодринаты."""
tag = self.create\_image(x, y, image=sprite.image, anchor='center', **kwargs)
sprite.set\_tag(tag)
sprite.set\_z(z)  \# устанавливаем z-координату спрайта
sprite.x = x
sprite.y = y
self.sprites.append(sprite)
self.sprites.sort(key=lambda sprite: sprite.z) \# сортировка спрайтов по z-координате

модуль baldursgame '''пользовательский модуль'''

from rpg.sprite import *
from rpg.game import *
from rpg.area import *
from rpg.actor import *
import datetime
import threading

def timer():
first\_game.update()
root.after(1000, timer)

root = tk.Tk()
root.geometry('1500x1500')

exit\_button = tk.Button(root, text="Exit", fg="red", command=root.destroy)
exit\_button.pack()

\# Создание экземпляра класса graphics, который будет взаимодействовать с окном
canvas = Graphics(root, width=1500, height=1500)

\# Загрузка изображения
im1\_1 = Sprite('images/fon1.png')
im1\_2 = Sprite('images/fon2.png')
im2\_1 = Sprite('images/person1.png')
im2\_2 = Sprite('images/person2.png')

\subsection{Модули и классы}
\subsection{Game}
\subsubsection{Описание модуля}
\paragraph{Конструктор и поля модуля}
def \_\_init\_\_(self,  canvas, window, **params) 
\begin{itemize} 
	\item self.rpg\_dict\_of\_area = {} 
	\item словарь, хранящий в себе множество экземпляров класса Area, {number - ключ : name Area - значение}
	\item self.team\_of\_pc = [] 
	\item список, хранящий в себе имена экземпляров класса Actor с параметром category = "pc"
	\item self.canvas = canvas 
	\item графика
	\item self.root = window 
	\item окно для графики
	\item self.current\_area = None 
	\item параметр хранящий, текущую зону
	\item self.scripts = {}  
	\item Словарь для хранения запущенных сценариев
	\item self.events = {} 
	\item Словарь для хранения запущенных event`ов сценариев
	\item self.canvas.bind("<Button-1>", self.mouse\_left\_click)
	\item обработчик клика
	\item Game.game = self
	\item экземпляр игры, для обращения к нему напрямую
\end{itemize}
\subsubsection{Методы}
\paragraph{new\_area}
def new\_area(self, name, area)
Описание метода: Добавляет новую зону в список.
\paragraph{set\_area}
def set\_area(self, name)
Описание метода: Устанавливает текущую зону, загружает графику зоны.
\paragraph{New\_actor}
def new\_actor(self, name, **params)
Описание метода: метод отвечающий за создание класса, потомка от Actor и создание поля из параметров, и установление их в начальные значения.
\paragraph{start\_script}
def start\_script(self, script\_function, script\_name, *args)
Описание метода: Запускает сценарий в отдельном потоке с возможностью остановки и передачи аргументов.
\paragraph{stop\_script}
def stop\_script(self, script\_name)
Описание метода: Останавливает сценарий по имени.
\paragraph{Add\_pc\_to\_team}
def add\_pc\_to\_team(self, pc)
Описание метода: метод отвечающий за добавление имени экземпляра класса Actor с параметром category = "pc" в список team\_of\_pc, хранящий имена всех игровых персонажей.
\paragraph{Remove\_pc\_from\_team}
def remove\_pc\_from\_team(self, pc)
Описание метода: метод отвечающий за удаление имени экземпляра класса Actor с параметром category = "pc" в список team\_of\_pc, хранящий имена всех игровых персонажей.
\paragraph{set\_team}
def set\_team(self, x, y, z)
Описание метода: Устанавливает координаты персонажей команды.
\paragraph{update}
def update(self)
Описание метода: Вызывается в таймере для обновления всех переменных в текущей зоне.
\paragraph{mouse\_left\_click}
def mouse\_left\_click(self, event)
Описание метода: обрабатывает клик мыши.
\paragraph{timer}
def timer(self)
Описание метода: Таймер дожен вызывать метод update постоянно.


\subsection{Area}
\subsubsection{Описание модуля}
\paragraph{Конструктор и поля модуля}
def \_\_init\_\_(self, **params)
\begin{itemize}
	\item self.area\_zone = params 
	\item параметр определяющий особенности конкретной зоны
	\item self.objects = [] 
	\item список, хранящий в себе множество экземпляров классов Item
	\item self.sprites = [] 
	\item список фоновых спрайтов
	\item self.rectangles = None 
	\item список, хранящий в себе множетво прямоугольников
\end{itemize}
\subsubsection{Методы}
\paragraph{Add\_sprite}
def add\_sprite(self, sprite, x, y, z)
Описание метода: Добавляет спрайт в зону.
\paragraph{add\_object}
def add\_object(self, obj, x, y, z)
Описание метода: Добавляет объект в зону.
\paragraph{remove\_object}
def remove\_object(self, obj)
Описание метода: Удаляет объект из зоны.
\paragraph{load\_sprites}
def load\_sprites(self)
Описание метода: Загружает все спрайты зоны.
\paragraph{add\_rect}
def add\_rect(self, rec)
Описание метода: Добавляет прямоугольник в зону.
\paragraph{entry\_script}
def entry\_script(self))
Описание метода: Запускается, когда команда входит в зону.
\paragraph{exit\_script}
def exit\_script(self)
Описание метода: Запускается, когда команда выходит из зоны.
\paragraph{update}
def update(self)
Описание метода: Изменяет и проверяет изменение всех персонажей в зоне.

\subsection{Sprite}
\subsubsection{Описание модуля}
\paragraph{Конструктор и поля модуля}
def \_\_init\_\_(self, image)
\begin{itemize}
	\item self.spr\_image = image
	\item Описание параметра: параметр хранит изображение конкретного экземпляра класса Sprite.
	\item self.tag = None
	\item self.spr\_x = x
	\item Описание параметра: параметр хранит числовое значение обозначающее расположение конкретного экземпляра класса Sprite.
	\item self.spr\_y = y
	\item Описание параметра: параметр хранит числовое значение обозначающее расположение конкретного экземпляра класса Sprite.
	\item self.spr\_z = z
	\item Описание параметра: параметр хранит числовое значение обозначающее расположение конкретного экземпляра класса Sprite.
\end{itemize}
\subsubsection{Методы}
\paragraph{set\_tag}
def set\_tag(self, tag)
\paragraph{set\_z}
def set\_z(self, z)
\paragraph{get\_tag}
def get\_tag(self)
\paragraph{set\_coords}
def set\_coords(self, new\_x, new\_y)
\paragraph{update}
def update(self)
\subsection{Graphics}
\subsubsection{Описание модуля}
\paragraph{Конструктор и поля модуля}
def \_\_init\_\_(self, master, **kwargs)
\begin{itemize}
	\item super().\_\_init\_\_(master, **kwargs)
	\item self.sprites = [] 
	\item список спрайтов
	\item Graphics.canvas = self
	\item параметр для работы с графикой, где к ней нужно обращаться напрямую
\end{itemize}
\subsubsection{Методы}
\paragraph{add\_sprite}
def add\_sprite(self, sprite, x, y, z, **kwargs)
Описание метода: Добавляет спрайт на Canvas
\paragraph{update}
def update(self)
Описание метода: Перерисовывает все спрайты
\paragraph{change\_sprite}
def change\_sprite(self, sprite, new\_sprite)
Описание метода: Меняет  спрайт на новый
\paragraph{delete\_sprite}
def delete\_sprite(self, sprite)
Описание метода: Удаляет спрайт с Canvas
\paragraph{clear\_all}
def clear\_all(self)
Описание метода: Удаляет все спрайты с Canvas

\subsection{Animation(Sprite)}
\subsubsection{Описание модуля}
\paragraph{Конструктор и поля модуля}
def \_\_init\_\_(self, frames, cycle=True)
\begin{itemize}
	\item super().\_\_init\_\_(frames[0])
	\item self.images = frames
	\item Описание параметра: """список кадров"""
	\item self.current\_frame = 0
	\item self.images = [tk.PhotoImage(file=frame) for frame in frames]   
	\item Загрузка всех кадров анимации
	\item self.image = self.images[0]
	\item Установка начального изображения
	\item self.speed = 3
	\item Описание параметра: """скорость анимации"""
	\item self.counter = self.speed
	\item self.cycle = cycle
	\item self.running = True
	
\end{itemize}
\subsubsection{Методы}
\paragraph{update:}
def update(self):
Меняет текущее изображение в списке изображений.

\subsection{Object}
\subsubsection{Описание модуля}
\paragraph{Конструктор и поля модуля}
def \_\_init\_\_(self, x, y, z, **params)
\begin{itemize}
	\item self.pos\_x = x
	\item координата x
	\item self.pos\_y = y
	\item координата y
	\item self.pos\_z = z
	\item координата z
	\item self.current\_state = None
	\item текущее состояние
	\item self.visible = True
	\item видим ли объект
	\item self.on\_click = lambda x : x
	\item возможно ли кликнуть по объекту
	\item if self.states is not None:
	self.set\_state(next(iter(self.states)))  # Установка первого состояния
	\item установка первого состояния если потребуется
	\item self.rectangle = Rectangle(x, y, 10, 10) # из спрайта
	\item прямоугольник объекта
\end{itemize}
\subsubsection{Методы}
\paragraph{set\_state}
def set\_state(self, state\_name):
Описание метода: меняет текущее состояние объекта
\paragraph{actor\_in}
 def actor\_in(self, actor):
Описание метода:Вызывается когда actor входит внутрь объекта
\paragraph{update}
def update(self)
Описание метода: ничего не делает

\subsection{Actor(Object)}
\subsubsection{Описание модуля}
\paragraph{Конструктор и поля модуля}
def \_\_init\_\_(self, x, y, z, **params)
\begin{itemize}
	\item self.sprite = self.states[next(iter(self.states))]
	\item
	\item super().\_\_init\_\_(x, y, z, **params)
	\item self.speed\_x = 0 
	\item значение скорости x
	\item self.speed\_y = 0  
	\item значение скорости y
	\item self.target\_x = 0
	\item координата x в которую будет двигаться персонаж
	\item self.target\_y = 0
	\item координата y в которую будет двигаться персонаж
	\item self.rectangle = Rectangle(self.pos\_x, self.pos\_y, self.sprite.image.width(), self.sprite.image.height())
	\item прямоугольник персонажа
	\item self.is\_attack = False
	\item состояние - атакует ли персонаж сейчас
\end{itemize}
\subsubsection{Методы}
\paragraph{update}
def update(self)
Описание метода: изменяет координаты и состояние персонажа.
\paragraph{search\_position}
def search\_position(self, new\_x, new\_y)
Описание метода:  Изменяет направление движения у персонажа.
\paragraph{stop\_move}
def stop\_move(self):
Описание метода: Останавливает движение персонажа.

\subsection{Adnd\_actor(Actor)}
\subsubsection{Описание модуля}
\paragraph{Конструктор и поля модуля}
def \_\_init\_\_(self, x, y, z, **params)
\begin{itemize}
	\item super().\_\_init\_\_(x, y, z, **params)
	\item self.on\_click = self.click
	\item событие по клику на персонажа
\end{itemize}
\subsubsection{Методы}
\paragraph{click}
def click(self)
Описание метода: вызывается при клике на персонажа.
\paragraph{attack}
def attack(self, actor)
Описание метода: совершает атаку по actor.
\paragraph{update}
def update(self)
Описание метода: обновляет состояние персонажа.

\subsection{Rectangle}
\subsubsection{Описание модуля}
\paragraph{Конструктор и поля модуля}
def \_\_init\_\_(self, x, y, width, height)
\begin{itemize}
	\item self.x = x
	\item координата x прямоугольника
	\item self.y = y
	\item координата y прямоугольника
	\item self.width = width
	\item ширина прямоугольника
	\item self.height = height
	\item высота прямоугольника
\end{itemize}
\subsubsection{Методы}
\paragraph{is\_in}
def is\_in(self, rect)
Описание метода: Проверяет, входит ли прямоугольник self в прямоугольник rect
\paragraph{is\_point\_inside}
def is\_point\_inside(self, target\_x, target\_y)
Описание метода: Проверяет, входит ли точка (x, y) в данный прямоугольник

\subsection{Portal(Object)}
\subsubsection{Описание модуля}
\paragraph{Конструктор и поля модуля}
def \_\_init\_\_(self, x, y, width, height, area, team\_x, team\_y)
\begin{itemize}
	\item self.states = None
	\item состояние портала
	\item self.sprite = None
	\item спрайт портала
	\item self.category = 'portal'
	\item категория портала
	\item super().\_\_init\_\_(x, y, 0)
	\item self.rectangle = Rectangle(x, y, width, height)
	\item прямоугольник портала
	\item self.area = area
	\item текущая зона
	\item self.team\_x = team\_x
	\item координата x в новой зоне в которую установят команду
	\item self.team\_y = team\_y
	\item координата y в новой зоне в которую установят команду
	\item self.visible = False
	\item видимость портала
\end{itemize}
\subsubsection{Методы}
\paragraph{actor\_in}
def actor\_in(self, actor)
Описание метода: Проверяет находится ли персонаж внутри портала

\subsection{Spell}
\subsubsection{Описание модуля}
\paragraph{Конструктор и поля модуля}
def \_\_init\_\_(self, name, level, type, damage)
\begin{itemize}
	\item self.spell\_name = name
	\item Описание параметра: параметр хранит название конкретного экземпляра класса Spell.
	\item self.spell\_level = level
	\item Описание параметра: параметр хранит числовое значение обозначающее уровень у конкретного экземпляра класса Spell.
	\item self.spell\_type = type
	\item Описание параметра: параметр хранит текстовое значение, обозначающее принадлежность к определённому типу заклинания (урон, лечение, перемещение) у конкретного экземпляра класса Spell.
	\item self.spell\_damage = damage
	\item Описание параметра: параметр хранит числовое значение обозначающее колличество единиц урона, у конкретного экземпляра класса Spell, на которое может быть уменьшено колличество единиц жизни(параметр obj\_hp) у другого экземпляра класса Object.

\end{itemize}
\subsubsection{Методы}
\paragraph{Cast\_spell}
def cast\_spell(self. actor1, actor2)
Описание метода: метод отвечающий за изменение поля obj\_hp экземпляра класса Object на число равное значению поля spell\_damage экземпляра класса Spell.
\paragraph{Learn\_spell}
def learn\_spell(self, name, level, list)
Описание метода: метод отвечающий за добавление в поле act\_list\_spells экземпляра класса Actor нового элемента.
\paragraph{Forget\_spell}
def def forget\_spell(self, name, level, list)
Описание метода: метод отвечающий за удаление из поля act\_list\_spells экземпляра класса Actor первого элемента.

\subsection{Item}
\subsubsection{Описание модуля}
\paragraph{Конструктор и поля модуля}
def \_\_init\_\_(self, name, category, type, ability)
\begin{itemize}
	\item self.it.category = category 
	\item Описание параметра: параметр хранит текстовое значение, обозначающее принадлежность к определённой категории предмета (оружие, доспех, магический предмет, прочее) у конкретного экземпляра класса Item.
	\item self.it.type = type 
	\item Описание параметра: параметр хранит текстовое значение, обозначающее принадлежность к определённому типу предмета, которое он может занимать в инвентаре (голова, одна рука, две руки, доспех, ноги, обувь, прочее) у конкретного экземпляра класса Item.
	\item self.it.ability = ability % сопособности предмета(доспех увеличивает класс доспеха, свиток новое заклинание и т.д.)
	\item Описание параметра: параметр хранит текстовое значение, обозначающее особенность (доспех, изменяет значение параметра obj\_ac у конкретного экземпляра класса Object, оружие изменяет значение параметра obj\_damage у конкретного экземпляра класса Object, магический предмет добавляет новый экземпляр класса Spell, в список act\_list\_spells конкретного экземпляра класса Actor, прочее, не изменяет параметров, но содержит текст, который будет выводится на экран, при взаимодействии пользователя с предметом) у конкретного экземпляра класса Item.
	\item self.it\_status\_cadr
	\item Описание параметра: параметр - хранит в себе текущий кадр анимации.
\end{itemize}
\subsubsection{Методы}
\paragraph{Use\_item}
def use\_item(self, ability, obj)
Описание метода: метод отвечающий за изменение полей obj\_hp, obj\_ac, obj\_speed экземпляра класса Object или полей act\_str, act\_agi экземпляра класса Actor на число равное значению поля it.ability экземпляра класса Item.
\paragraph{Equip\_item}
def equip\_item(actor, name, inventory)
Описание метода: метод отвечающий за добавление в список act\_inventory экземпляра класса Actor элемента с названием экземпляра класса Item.

