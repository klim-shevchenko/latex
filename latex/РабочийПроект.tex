\section{Рабочий проект}
\subsection{Классы, используемые при разработке приложения}

Можно выделить следующий список классов и их методов, использованных при разработке приложения (таблица \ref{class:table}). Пример таблицы с уменьшенным межстрочным интервалом.

\renewcommand{\arraystretch}{0.8} % уменьшение расстояний до сетки таблицы
\begin{xltabular}{\textwidth}{|X|p{2.5cm}|>{\setlength{\baselineskip}{0.7\baselineskip}}p{4.85cm}|>{\setlength{\baselineskip}{0.7\baselineskip}}p{4.85cm}|}
\caption{Описание классов платформы, используемых в приложении\label{class:table}}\\
\hline \centrow \setlength{\baselineskip}{0.7\baselineskip} Название класса & \centrow \setlength{\baselineskip}{0.7\baselineskip} Модуль, к которому относится класс & \centrow Описание класса & \centrow Методы \\
\hline \centrow 1 & \centrow 2 & \centrow 3 & \centrow 4\\ \hline
\endfirsthead
\caption*{Продолжение таблицы \ref{class:table}}\\
\hline \centrow 1 & \centrow 2 & \centrow 3 & \centrow 4\\ \hline
\finishhead
sprite & rpg & Sprite – Инициализация класса Sprite для работы с изображениями на холсте Canvas. & set\_tag(self, tag)

Устанавливает тег для спрайта.

set\_z(self, z)

Устанавливает z-координату спрайта.

get\_tag(self)

Возвращает тег спрайта.

set\_coords(self, new\_x, new\_y)

Обновляет координаты спрайта.

update(self)
Обновляет анимацию спрайта, если она у него есть.\\
\hline animation & rpg & Animation – Класс анимации спрайта & update(self)

Меняет текущее изображение в списке изображений.\\
\hline graphics & rpg & Graphics – Класс с методами для работы со спрайтами & add\_sprite(self, sprite, x, y, z, **kwargs)

Добавляет спрайт на Canvas.

update(self)

Перерисовывает все спрайты.

change\_sprite(self, sprite, new\_sprite)

Меняет спрайт на новый в Canvas.

delete\_sprite(self, sprite)

Удаляет спрайт с Canvas.

clear\_all(self)

Удаляет все спрайты с Canvas.\\
\hline rectangle & rpg & Rectangle – Класс прямоугольника, используемый для перемещения & is\_in(self, rect)

Проверяет, входит ли прямоугольник self в прямоугольник rect.

is\_point\_inside(self, target\_x, target\_y)

Проверяет, входит ли точка (x, y) в данный прямоугольник.\\
\hline object & rpg & Object – Класс объекта, который будет изменяться методами игровой системы и методами графической системы & set\_state(self, state\_name)

Меняет текущее состояние объекта.

actor\_in(self, actor)

Вызывается когда actor входит внутрь объекта.

update(self)

Этот метод будет изменён в классах наследниках от object.\\
\hline portal & rpg & Portal – Класс портала, используемый для перемещения команды персонажей в новую зону & actor\_in(self, actor)

Проверяет находится ли персонаж внутри портала.\\
\hline actor & rpg & Actor – Класс Actor для работы с персонажем & update(self)

Изменяет координаты и состояние персонажа.

search\_position(self, new\_x, new\_y)

Изменяет направление движения у персонажа.

stop\_move(self)

Останавливает движение персонажа.\\
\hline adnd\_actor & rpg & Adnd\_actor – Класс Adnd\_actor содержащий основные механики взаимодействия с другими персонажами & click(self)

Вызывается при клике на персонажа.

attack(self, actor)

Совершает атаку по actor.

update(self)

Обновляет состояние персонажа.\\
\hline area & rpg & Area – Класс Area, содержащий все поля и методы используемые в каждой зоне & add\_sprite(self, sprite, x, y, z)

Добавляет спрайт в зону.

add\_object(self, obj, x, y, z)

Добавляет объект в зону.

remove\_object(self, obj)

Удаляет объект из зоны.

load\_sprites(self)

Загружает все спрайты зоны.

add\_rect(self, rec)

Добавляет прямоугольник в зону.

entry\_script(self)

Запускается, когда команда входит в зону

exit\_script(self)

Запускается, когда команда выходит из зоны

update(self)

Изменяет и проверяет изменение всех объектов в зоне.\\
\hline game & rpg & Game – Класс системы управления игрой & new\_area(self, name, area)

Добавляет новую зону в список.

set\_area(self, name)

Устанавливает текущую зону, загружает графику зоны.

new\_actor(self, name, **params)

Создаёт класс, потомок от Actor и создаёт поле из параметров, и установление их в начальные значения.

add\_pc\_to\_team(self, pc)

Добавляет персонажа в команду.

remove\_pc\_from\_team(self, pc)

Удаляет персонажа из команды.

start\_script(self, script\_function, script\_name, *args)

Запускает сценарий в отдельном потоке с возможностью остановки и передачи аргументов.

stop\_script(self, script\_name)

Останавливает сценарий по имени.

set\_team(self, x, y, z)

Устанавливает координаты персонажей команды.

update(self)

Вызывается в таймере для обновления всех переменных в текущей зоне.\\


\hline & & & mouse\_left\_click(self, event)

Обрабатывает клик мыши.

timer(self)

Таймер дожен вызывать метод update постоянно.\\
\hline village & рабочая система & Village – Класс зоны Village & \_\_init\_\_(self)

Инициализирует все поля и методы внутри конкретной зоны.\\
\hline footman & рабочая система & Footman – Класс наследник от Adnd\_actor & \_\_init\_\_(self, x, y, z)

Инициализирует все поля и методы внутри конкретного экземпляра класса Footman.\\
\hline grunt & рабочая система & Grunt – Класс наследник от Adnd\_actor & \_\_init\_\_(self, x, y, z)

Инициализирует все поля и методы внутри конкретного экземпляра класса Grunt.\\
\hline mage & рабочая система & Mage – Класс наследник от Adnd\_actor & \_\_init\_\_(self, x, y, z)

Инициализирует все поля и методы внутри конкретного экземпляра класса Mage.\\
\hline ruins & рабочая система & Ruins – Класс зоны Ruins & \_\_init\_\_(self)

Инициализирует все поля и методы внутри конкретной зоны.

walk(self, step\_x, step\_y, actor)

Сценарий для движения персонажа.

ai(self, actor)

Сценарий для персонажей противников.\\
\hline bggame & рабочая система & BaldursGame – Класс игры BaldursGame & \_\_init\_\_(self, x, y, z)

Инициализирует все поля и методы внутри конкретной игры.\\
\hline main & рабочая система & Main – Класс Main & методы отсутствуют

\end{xltabular}
\renewcommand{\arraystretch}{1.0} % восстановление сетки

\subsection{Модульное тестирование разработанного приложения}

Модульный тест для класса Rectangle из модели данных представлен на рисунке \ref{unitUser:image}.

\begin{figure}[H]
\begin{lstlisting}[language=Python]
import unittest
from rpg.rectangle import Rectangle
class TestRectangle(unittest.TestCase):
	def setUp(self):
		# Прямоугольник для использования в тестах
		self.rect = Rectangle(1, 1, 4, 4)

	def test_inside(self):
	'''Тест: прямоугольник внутри другого'''
		rect_outside = Rectangle(0, 0, 6, 6)
		self.assertTrue(self.rect.is_in(rect_outside))

	def test_outside(self):
	'''Тест: прямоугольник снаружи другого'''
		rect_inside = Rectangle(2, 2, 2, 2)
		self.assertFalse(self.rect.is_in(rect_inside))

	def test_apartside(self):
	'''Тест: прямоугольник отдельно от другого'''
		rect_apart = Rectangle(6, 6, 2, 2)
		self.assertFalse(self.rect.is_in(rect_apart))

	def test_touching_left(self):
	'''Тест: прямоугольник касается слева'''
		touching_left = Rectangle(0, 2, 1, 1)
		self.assertFalse(self.rect.is_in(touching_left))

	def test_touching_right(self):
		'''Тест: прямоугольник касается справа'''
		touching_right = Rectangle(5, 2, 1, 1)
		self.assertFalse(self.rect.is_in(touching_right))

	def test_touching_top(self):
		'''Тест: прямоугольник касается сверху'''
		touching_top = Rectangle(2, 5, 1, 1)
		self.assertFalse(self.rect.is_in(touching_top))

	def test_touching_bottom(self):
		'''Тест: прямоугольник касается снизу'''
		touching_bottom = Rectangle(2, 0, 1, 1)
		self.assertFalse(self.rect.is_in(touching_bottom))

	def test_intersect_left(self):
		'''Тест: пересечение прямоугольника слева'''
		intersect_left = Rectangle(0, 2, 3, 2)
		self.assertTrue(self.rect.is_in(intersect_left))

	def test_intersect_right(self):
		'''Тест: пересечение прямоугольника справа'''
		intersect_right = Rectangle(3, 2, 3, 2)
		self.assertTrue(self.rect.is_in(intersect_right))

	def test_intersect_top(self):
		'''Тест: пересечение прямоугольника сверху'''
		intersect_top = Rectangle(2, 3, 2, 3)
		self.assertTrue(self.rect.is_in(intersect_top))

	def test_intersect_bottom(self):
		'''Тест: пересечение прямоугольника снизу'''
		intersect_bottom = Rectangle(2, 0, 2, 3)
		self.assertTrue(self.rect.is_in(intersect_bottom))

	def test_is_point_inside(self):
		# Создайте прямоугольник
		rect = Rectangle(0, 0, 10, 10)

		# Точка внутри прямоугольника
		self.assertTrue(rect.is_point_inside(5, 5))

		# Точка на границе прямоугольника
		self.assertTrue(rect.is_point_inside(0, 0))
		self.assertTrue(rect.is_point_inside(0, 10))
		self.assertTrue(rect.is_point_inside(10, 0))
		self.assertTrue(rect.is_point_inside(10, 10))

		# Точка вне прямоугольника
		self.assertFalse(rect.is_point_inside(-1, -1))
		self.assertFalse(rect.is_point_inside(11, 11))
		self.assertFalse(rect.is_point_inside(5, -5))
		self.assertFalse(rect.is_point_inside(-5, 5))
\end{lstlisting}  
\caption{Модульный тест класса User}
\label{unitUser:image}
\end{figure}

\subsection{Системное тестирование разработанного приложения}

На рисунке \ref{systemtest_recponse:image} представлен пример работы программы.
\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{systemtest\_recponse}
	\caption{Пример работы программы с одним персонажем внутри одной, игровой зоны Village}
	\label{systemtest_recponse:image}
\end{figure}

На рисунке \ref{systemtest_recponse1:image} представлен пример анимации персонажа.
\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{systemtest\_recponse1}
	\caption{Анимация передвижения персонажа mage}
	\label{systemtest_recponse1:image}
\end{figure}

На рисунке \ref{systemtest_recponse2:image} представлен пример движения персонажа.
\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{systemtest\_recponse2}
	\caption{Передвижение персонажа mage}
	\label{systemtest_recponse2:image}
\end{figure}

На рисунке \ref{systemtest_recponse3:image} представлен пример невозможности выхода за границу зоны.
\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{systemtest\_recponse3}
	\caption{Персонаж mage, не может выйти за пределы видимой зоны Village}
	\label{systemtest_recponse3:image}
\end{figure}

На рисунке \ref{systemtest_recponse4:image} представлен пример перехода персонажа из зоны.
\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{systemtest\_recponse4}
	\caption{Персонаж mage, переходит из зоны Village в зону Ruins}
	\label{systemtest_recponse4:image}
\end{figure}

На рисунке \ref{systemtest_recponse5:image} представлен пример установки новой зоны.
\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{systemtest\_recponse5}
	\caption{Пример работы программы с тремя персонажами внутри одной, игровой зоны Ruins}
	\label{systemtest_recponse5:image}
\end{figure}

На рисунке \ref{systemtest_recponse6:image} представлен пример работы сценария движения персонажа.
\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{systemtest\_recponse6}
	\caption{Пример работы сценария walk(50, 50, self.footman), игровой зоны Ruins}
	\label{systemtest_recponse6:image}
\end{figure}

На рисунке \ref{systemtest_recponse7:image} представлен пример работы сценария поведения персонажа противника.
\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{systemtest\_recponse7}
	\caption{Пример работы сценария ai(self.grunt), игровой зоны Ruins}
	\label{systemtest_recponse7:image}
\end{figure}

На рисунке \ref{systemtest_recponse8:image} представлен пример работы метода click персонажа.
\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{systemtest\_recponse8}
	\caption{Вызов метода click, у персонажа Grunt}
	\label{systemtest_recponse8:image}
\end{figure}